<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-book/java/Java 基础" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Java 基础 | WBlog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://blog.wlgs.site/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://blog.wlgs.site/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://blog.wlgs.site/docs/book/java/Java-basic"><meta data-rh="true" property="og:locale" content="zh"><meta data-rh="true" property="og:locale:alternate" content="en"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Java 基础 | WBlog"><meta data-rh="true" name="description" content="Java 基础 - 面向对象"><meta data-rh="true" property="og:description" content="Java 基础 - 面向对象"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://blog.wlgs.site/docs/book/java/Java-basic"><link data-rh="true" rel="alternate" href="https://blog.wlgs.site/docs/book/java/Java-basic" hreflang="zh"><link data-rh="true" rel="alternate" href="https://blog.wlgs.site/en/docs/book/java/Java-basic" hreflang="en"><link data-rh="true" rel="alternate" href="https://blog.wlgs.site/docs/book/java/Java-basic" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Java 基础","item":"https://blog.wlgs.site/docs/book/java/Java-basic"}]}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="WBlog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="WBlog Atom Feed">





<script src="/js/donation.js" async></script><link rel="stylesheet" href="/assets/css/styles.c5e3deb1.css">
<script src="/assets/js/runtime~main.0735b229.js" defer="defer"></script>
<script src="/assets/js/main.3eddb39d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_CRM7" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">WBlog</b></a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/blog">博客</a><a class="navbar__item navbar__link" sidebarid="noteSidebar" href="/docs/note">笔记</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">手册</a><ul class="dropdown__menu"><li><a aria-current="page" class="dropdown__link dropdown__link--active" sidebarid="javaSidebar" href="/docs/book/java">Java编程</a></li><li><a class="dropdown__link" sidebarid="codeSidebar" href="/docs/book/code">Code题解</a></li><li><a class="dropdown__link" sidebarid="foodSidebar" href="/docs/book/food">菜谱</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">工具</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/page?file=md">MD排版</a></li><li><a class="dropdown__link" href="/page?file=dict">Dict</a></li></ul></div><a href="#" class="navbar__item navbar__link donation-link">打赏</a><div class="toggle_ZZEd colorModeToggle_hBtq"><button class="clean-btn toggleButton_by9D toggleButtonDisabled_KL6r" type="button" disabled="" title="system mode" aria-label="切换浅色/暗黑模式（当前为system mode）"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_wWRv lightToggleIcon_MqLn"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_wWRv darkToggleIcon_i3Nj"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_wWRv systemToggleIcon__88S"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_MWeV"><div class="navbar__search searchBarContainer_tJxS" dir="ltr"><input placeholder="搜索" aria-label="Search" class="navbar__search-input searchInput_VZxq" value=""><div class="loadingRing_AWsq searchBarLoadingRing_N8KY"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_srg8"><div class="docsWrapper_U8Pi"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_fC5I" type="button"></button><div class="docRoot_gbPH"><aside class="theme-doc-sidebar-container docSidebarContainer_mISD"><div class="sidebarViewport_Ii8V"><div class="sidebar_UY4c"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_U21l"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/book/java/">Java</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/book/java/Java-basic">Java 基础</a></li></ul></nav></div></div></aside><main class="docMainContainer_RkYj"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_tYIO"><div class="docItemContainer_FQ0X"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_olWw" aria-label="页面路径"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_mnpJ"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Java 基础</span></li></ul></nav><div class="tocCollapsible_ixBv theme-doc-toc-mobile tocMobile_KDTE"><button type="button" class="clean-btn tocCollapsibleButton_D0Bk">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>Java 基础</h1></header><h2 class="anchor anchorWithStickyNavbar_Donx" id="java-基础---面向对象">Java 基础 - 面向对象<a href="#java-基础---面向对象" class="hash-link" aria-label="Java 基础 - 面向对象的直接链接" title="Java 基础 - 面向对象的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="三大特性">三大特性<a href="#三大特性" class="hash-link" aria-label="三大特性的直接链接" title="三大特性的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="封装">封装<a href="#封装" class="hash-link" aria-label="封装的直接链接" title="封装的直接链接">​</a></h4>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点:</p>
<ul>
<li>减少耦合: 可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担: 可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能: 可以通过剖析确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险: 即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int gender;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getGender() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void work() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (18 &lt;= age &amp;&amp; age &lt;= 50) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(name + &quot; is working very hard!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(name + &quot; can&#x27;t work any more!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="继承">继承<a href="#继承" class="hash-link" aria-label="继承的直接链接" title="继承的直接链接">​</a></h4>
<p>继承实现了 <strong>IS-A</strong> 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 <strong>向上转型</strong> 。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Animal animal = new Cat();</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="多态">多态<a href="#多态" class="hash-link" aria-label="多态的直接链接" title="多态的直接链接">​</a></h4>
<p>多态分为编译时多态和运行时多态:</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件:</p>
<ul>
<li>继承</li>
<li>覆盖(重写)</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类(Instrument)有两个子类: Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Instrument {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void play() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Instrument is playing...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Wind extends Instrument {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void play() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Wind is playing...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Percussion extends Instrument {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void play() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;Percussion is playing...&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Music {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Instrument&gt; instruments = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instruments.add(new Wind());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        instruments.add(new Percussion());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(Instrument instrument : instruments) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            instrument.play();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_Donx" id="java-基础---知识点">Java 基础 - 知识点<a href="#java-基础---知识点" class="hash-link" aria-label="Java 基础 - 知识点的直接链接" title="Java 基础 - 知识点的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="数据类型">数据类型<a href="#数据类型" class="hash-link" aria-label="数据类型的直接链接" title="数据类型的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="包装类型">包装类型<a href="#包装类型" class="hash-link" aria-label="包装类型的直接链接" title="包装类型的直接链接">​</a></h4>
<p>八个基本类型:</p>
<ul>
<li>boolean/1</li>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
</ul>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Integer x = 2;     // 装箱</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int y = x;         // 拆箱</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="缓存池">缓存池<a href="#缓存池" class="hash-link" aria-label="缓存池的直接链接" title="缓存池的直接链接">​</a></h4>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于:</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Integer x = new Integer(123);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer y = new Integer(123);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(x == y);    // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer z = Integer.valueOf(123);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer k = Integer.valueOf(123);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(z == k);   // true</span><br></span></code></pre></div></div>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static Integer valueOf(int i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new Integer(i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">static final int low = -128;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final int high;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static final Integer cache[];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // high value may be configured by property</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int h = 127;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String integerCacheHighPropValue =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (integerCacheHighPropValue != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int i = parseInt(integerCacheHighPropValue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            i = Math.max(i, 127);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Maximum array size is Integer.MAX_VALUE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch( NumberFormatException nfe) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // If the property cannot be parsed into an int, ignore it.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    high = h;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cache = new Integer[(high - low) + 1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int j = low;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for(int k = 0; k &lt; cache.length; k++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cache[k] = new Integer(j++);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // range [-128, 127] must be interned (JLS7 5.1.7)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    assert IntegerCache.high &gt;= 127;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Integer m = 123;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer n = 123;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(m == n); // true</span><br></span></code></pre></div></div>
<p>基本类型对应的缓冲池如下:</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p>
<p>如果在缓冲池之外：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Integer m = 323;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer n = 323;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(m == n); // false</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="string">String<a href="#string" class="hash-link" aria-label="String的直接链接" title="String的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="概览">概览<a href="#概览" class="hash-link" aria-label="概览的直接链接" title="概览的直接链接">​</a></h4>
<p>String 被声明为 final，因此它不可被继承。</p>
<p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public final class String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** The value is used for character storage. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final char value[];</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="不可变的好处">不可变的好处<a href="#不可变的好处" class="hash-link" aria-label="不可变的好处的直接链接" title="不可变的好处的直接链接">​</a></h4>
<p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="string-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder<a href="#string-stringbuffer-and-stringbuilder" class="hash-link" aria-label="String, StringBuffer and StringBuilder的直接链接" title="String, StringBuffer and StringBuilder的直接链接">​</a></h4>
<p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="stringintern">String.intern()<a href="#stringintern" class="hash-link" aria-label="String.intern()的直接链接" title="String.intern()的直接链接">​</a></h4>
<p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">String s1 = new String(&quot;aaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s2 = new String(&quot;aaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(s1 == s2);           // false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s3 = s1.intern();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(s1.intern() == s3);  // true</span><br></span></code></pre></div></div>
<p>如果是采用 &quot;bbb&quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">String s4 = &quot;bbb&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s5 = &quot;bbb&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(s4 == s5);  // true</span><br></span></code></pre></div></div>
<ul>
<li><strong>HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区</strong>？</li>
</ul>
<ol>
<li>运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个<strong>逻辑上的概念</strong>；而堆区，永久代以及元空间是实际的存放位置。</li>
<li>不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。</li>
<li>HotSpot也是发展的，由于<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener noreferrer">一些问题在新窗口打开</a>的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，<strong>实际的存储位置</strong>是有差异的，具体看如下表格：</li>
</ol>
<table><thead><tr><th>JDK版本</th><th>是否有永久代，字符串常量池放在哪里？</th><th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead><tbody><tr><td>jdk1.6及之前</td><td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td><td>这个时期方法区在HotSpot中是由永久代来实现的，以至于<strong>这个时期说方法区就是指永久代</strong></td></tr><tr><td>jdk1.7</td><td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td><td>这个时期方法区在HotSpot中由<strong>永久代</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr><tr><td>jdk1.8及之后</td><td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td><td>这个时期方法区在HotSpot中由本地内存的<strong>元空间</strong>（类型信息、字段、方法、常量）和<strong>堆</strong>（字符串常量池、静态变量）共同实现</td></tr></tbody></table>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="运算">运算<a href="#运算" class="hash-link" aria-label="运算的直接链接" title="运算的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="参数传递">参数传递<a href="#参数传递" class="hash-link" aria-label="参数传递的直接链接" title="参数传递的直接链接">​</a></h4>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Dog {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Dog(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void setName(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String getObjectAddress() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class PassByValueExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Dog dog = new Dog(&quot;A&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getObjectAddress()); // Dog@4554617c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        func(dog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getObjectAddress()); // Dog@4554617c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getName());          // A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void func(Dog dog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getObjectAddress()); // Dog@4554617c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dog = new Dog(&quot;B&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getObjectAddress()); // Dog@74a14482</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getName());          // B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>但是如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class PassByValueExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Dog dog = new Dog(&quot;A&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        func(dog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getName());          // B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void func(Dog dog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dog.setName(&quot;B&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="float-与-double">float 与 double<a href="#float-与-double" class="hash-link" aria-label="float 与 double的直接链接" title="float 与 double的直接链接">​</a></h4>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">// float f = 1.1;</span><br></span></code></pre></div></div>
<p>1.1f 字面量才是 float 类型。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">float f = 1.1f;</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="隐式类型转换">隐式类型转换<a href="#隐式类型转换" class="hash-link" aria-label="隐式类型转换的直接链接" title="隐式类型转换的直接链接">​</a></h4>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">short s1 = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// s1 = s1 + 1;</span><br></span></code></pre></div></div>
<p>但是使用 += 运算符可以执行隐式类型转换。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">s1 += 1;</span><br></span></code></pre></div></div>
<p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">s1 = (short) (s1 + 1);</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="switch">switch<a href="#switch" class="hash-link" aria-label="switch的直接链接" title="switch的直接链接">​</a></h4>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">String s = &quot;a&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">switch (s) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case &quot;a&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;aaa&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    case &quot;b&quot;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;bbb&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">// long x = 111;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// switch (x) { // Incompatible types. Found: &#x27;long&#x27;, required: &#x27;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//     case 111:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         System.out.println(111);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//     case 222:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         System.out.println(222);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// }</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="继承-1">继承<a href="#继承-1" class="hash-link" aria-label="继承的直接链接" title="继承的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="访问权限">访问权限<a href="#访问权限" class="hash-link" aria-label="访问权限的直接链接" title="访问权限的直接链接">​</a></h4>
<p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 共有字段，如果在某个时刻，我们想要使用 int 去存储 id 字段，那么就需要去修改所有的客户端代码。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class AccessExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class AccessExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getId() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return id + &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setId(String id) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.id = Integer.valueOf(id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class AccessWithInnerClassExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private class InnerClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private InnerClass innerClass;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AccessWithInnerClassExample() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        innerClass = new InnerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getValue() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return innerClass.x;  // 直接访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="抽象类与接口">抽象类与接口<a href="#抽象类与接口" class="hash-link" aria-label="抽象类与接口的直接链接" title="抽象类与接口的直接链接">​</a></h4>
<p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractClassExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected int x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public abstract void func1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void func2() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;func2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class AbstractExtendClassExample extends AbstractClassExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void func1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;func1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// AbstractClassExample ac1 = new AbstractClassExample(); // &#x27;AbstractClassExample&#x27; is abstract; cannot be instantiated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AbstractClassExample ac2 = new AbstractExtendClassExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ac2.func1();</span><br></span></code></pre></div></div>
<p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>
<p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public interface InterfaceExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void func1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default void func2(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;func2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int x = 123;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // int y;               // Variable &#x27;y&#x27; might not have been initialized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int z = 0;       // Modifier &#x27;public&#x27; is redundant for interface fields</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // private int k = 0;   // Modifier &#x27;private&#x27; not allowed here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // protected int l = 0; // Modifier &#x27;protected&#x27; not allowed here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // private void fun3(); // Modifier &#x27;private&#x27; not allowed here</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class InterfaceImplementExample implements InterfaceExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void func1() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;func1&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// InterfaceExample ie1 = new InterfaceExample(); // &#x27;InterfaceExample&#x27; is abstract; cannot be instantiated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">InterfaceExample ie2 = new InterfaceImplementExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ie2.func1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(InterfaceExample.x);</span><br></span></code></pre></div></div>
<p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口:</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类:</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="super">super<a href="#super" class="hash-link" aria-label="super的直接链接" title="super的直接链接">​</a></h4>
<ul>
<li>访问父类的构造函数: 可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员: 如果子类重写了父类的中某个方法的实现，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class SuperExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected int x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected int y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SuperExample(int x, int y) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.x = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.y = y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void func() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;SuperExample.func()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SuperExtendExample extends SuperExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SuperExtendExample(int x, int y, int z) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(x, y);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.z = z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void func() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.func();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;SuperExtendExample.func()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SuperExample e = new SuperExtendExample(1, 2, 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e.func();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SuperExample.func()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SuperExtendExample.func()</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="重写与重载">重写与重载<a href="#重写与重载" class="hash-link" aria-label="重写与重载的直接链接" title="重写与重载的直接链接">​</a></h4>
<p><strong>1. 重写(Override)</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有以下两个限制:</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p>
<p><strong>2. 重载(Overload)</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="object-通用方法">Object 通用方法<a href="#object-通用方法" class="hash-link" aria-label="Object 通用方法的直接链接" title="Object 通用方法的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="概览-1">概览<a href="#概览-1" class="hash-link" aria-label="概览的直接链接" title="概览的直接链接">​</a></h4>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public final native Class&lt;?&gt; getClass()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public native int hashCode()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public boolean equals(Object obj)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected native Object clone() throws CloneNotSupportedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public String toString()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final native void notify()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final native void notifyAll()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final native void wait(long timeout) throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void wait(long timeout, int nanos) throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public final void wait() throws InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected void finalize() throws Throwable {}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="equals">equals()<a href="#equals" class="hash-link" aria-label="equals()的直接链接" title="equals()的直接链接">​</a></h4>
<p><strong>1. 等价关系</strong></p>
<p>(一)自反性</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">x.equals(x); // true</span><br></span></code></pre></div></div>
<p>(二)对称性</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">x.equals(y) == y.equals(x); // true</span><br></span></code></pre></div></div>
<p>(三)传递性</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">if (x.equals(y) &amp;&amp; y.equals(z))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    x.equals(z); // true;</span><br></span></code></pre></div></div>
<p>(四)一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">x.equals(y) == x.equals(y); // true</span><br></span></code></pre></div></div>
<p>(五)与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">x.equals(null); // false;</span><br></span></code></pre></div></div>
<p><strong>2. equals() 与 ==</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Integer x = new Integer(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer y = new Integer(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(x.equals(y)); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(x == y);      // false</span><br></span></code></pre></div></div>
<p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class EqualExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EqualExample(int x, int y, int z) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.x = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.y = y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.z = z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean equals(Object o) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this == o) return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (o == null || getClass() != o.getClass()) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        EqualExample that = (EqualExample) o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (x != that.x) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (y != that.y) return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return z == that.z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="hashcode">hashCode()<a href="#hashcode" class="hash-link" aria-label="hashCode()的直接链接" title="hashCode()的直接链接">​</a></h4>
<p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">EqualExample e1 = new EqualExample(1, 1, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EqualExample e2 = new EqualExample(1, 1, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(e1.equals(e2)); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(e1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">set.add(e2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(set.size());   // 2</span><br></span></code></pre></div></div>
<p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来，可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>
<p>一个数与 31 相乘可以转换成移位和减法: <code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public int hashCode() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int result = 17;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 31 * result + x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 31 * result + y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = 31 * result + z;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="tostring">toString()<a href="#tostring" class="hash-link" aria-label="toString()的直接链接" title="toString()的直接链接">​</a></h4>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class ToStringExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ToStringExample(int number) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.number = number;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ToStringExample example = new ToStringExample(123);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(example.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ToStringExample@4554617c</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="clone">clone()<a href="#clone" class="hash-link" aria-label="clone()的直接链接" title="clone()的直接链接">​</a></h4>
<p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class CloneExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CloneExample e1 = new CloneExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// CloneExample e2 = e1.clone(); // &#x27;clone()&#x27; has protected access in &#x27;java.lang.Object&#x27;</span><br></span></code></pre></div></div>
<p>重写 clone() 得到以下实现:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class CloneExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected CloneExample clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (CloneExample)super.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CloneExample e1 = new CloneExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CloneExample e2 = e1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (CloneNotSupportedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">java.lang.CloneNotSupportedException: CloneExample</span><br></span></code></pre></div></div>
<p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class CloneExample implements Cloneable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Object clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class ShallowCloneExample implements Cloneable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int[] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShallowCloneExample() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = new int[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void set(int index, int value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr[index] = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected ShallowCloneExample clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (ShallowCloneExample) super.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ShallowCloneExample e1 = new ShallowCloneExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ShallowCloneExample e2 = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e2 = e1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (CloneNotSupportedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e1.set(2, 222);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(e2.get(2)); // 222</span><br></span></code></pre></div></div>
<p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class DeepCloneExample implements Cloneable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int[] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DeepCloneExample() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = new int[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void set(int index, int value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr[index] = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected DeepCloneExample clone() throws CloneNotSupportedException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DeepCloneExample result = (DeepCloneExample) super.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result.arr = new int[arr.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.arr[i] = arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DeepCloneExample e1 = new DeepCloneExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DeepCloneExample e2 = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e2 = e1.clone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (CloneNotSupportedException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e1.set(2, 222);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(e2.get(2)); // 2</span><br></span></code></pre></div></div>
<p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class CloneConstructorExample {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int[] arr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CloneConstructorExample() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = new int[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public CloneConstructorExample(CloneConstructorExample original) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr = new int[original.arr.length];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; original.arr.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            arr[i] = original.arr[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void set(int index, int value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        arr[index] = value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arr[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CloneConstructorExample e1 = new CloneConstructorExample();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CloneConstructorExample e2 = new CloneConstructorExample(e1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e1.set(2, 222);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(e2.get(2)); // 2</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="关键字">关键字<a href="#关键字" class="hash-link" aria-label="关键字的直接链接" title="关键字的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="final">final<a href="#final" class="hash-link" aria-label="final的直接链接" title="final的直接链接">​</a></h4>
<p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">final int x = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">final A y = new A();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y.a = 1;</span><br></span></code></pre></div></div>
<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="static">static<a href="#static" class="hash-link" aria-label="static的直接链接" title="static的直接链接">​</a></h4>
<p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量: 又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它；静态变量在内存中只存在一份。</li>
<li>实例变量: 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int x;         // 实例变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int y;  // 静态变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        A a = new A();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int x = a.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int y = A.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法(abstract)。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void func1(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void func1(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int a = x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class A {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;123&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        A a1 = new A();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        A a2 = new A();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">123</span><br></span></code></pre></div></div>
<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class OuterClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    class InnerClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class StaticInnerClass {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        OuterClass outerClass = new OuterClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        InnerClass innerClass = outerClass.new InnerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        StaticInnerClass staticInnerClass = new StaticInnerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">import static com.xxx.ClassName.*</span><br></span></code></pre></div></div>
<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static String staticField = &quot;静态变量&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;静态语句块&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public String field = &quot;实例变量&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;普通语句块&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>最后才是构造函数的初始化。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public InitialOrderTest() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;构造函数&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>存在继承的情况下，初始化顺序为:</p>
<ul>
<li>父类(静态变量、静态语句块)</li>
<li>子类(静态变量、静态语句块)</li>
<li>父类(实例变量、普通语句块)</li>
<li>父类(构造函数)</li>
<li>子类(实例变量、普通语句块)</li>
<li>子类(构造函数)</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="反射">反射<a href="#反射" class="hash-link" aria-label="反射的直接链接" title="反射的直接链接">​</a></h3>
<p>每个类都有一个 <strong>Class</strong> 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类:</p>
<ul>
<li><strong>Field</strong> : 可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> : 可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> : 可以用 Constructor 创建新的对象。</li>
</ul>
<p><strong>Advantages of Using Reflection:</strong></p>
<ul>
<li><strong>Extensibility Features</strong> : An application may make use of external, user-defined classes by creating instances of extensibility objects using their fully-qualified names.</li>
<li><strong>Class Browsers and Visual Development Environments</strong> : A class browser needs to be able to enumerate the members of classes. Visual development environments can benefit from making use of type information available in reflection to aid the developer in writing correct code.</li>
<li><strong>Debuggers and Test Tools</strong> : Debuggers need to be able to examine private members on classes. Test harnesses can make use of reflection to systematically call a discoverable set APIs defined on a class, to insure a high level of code coverage in a test suite.</li>
</ul>
<p><strong>Drawbacks of Reflection:</strong></p>
<p>Reflection is powerful, but should not be used indiscriminately. If it is possible to perform an operation without using reflection, then it is preferable to avoid using it. The following concerns should be kept in mind when accessing code via reflection.</p>
<ul>
<li><strong>Performance Overhead</strong> : Because reflection involves types that are dynamically resolved, certain Java virtual machine optimizations can not be performed. Consequently, reflective operations have slower performance than their non-reflective counterparts, and should be avoided in sections of code which are called frequently in performance-sensitive applications.</li>
<li><strong>Security Restrictions</strong> : Reflection requires a runtime permission which may not be present when running under a security manager. This is in an important consideration for code which has to run in a restricted security context, such as in an Applet.</li>
<li><strong>Exposure of Internals</strong> <!-- -->:Since<!-- --> reflection allows code to perform operations that would be illegal in non-reflective code, such as accessing private fields and methods, the use of reflection can result in unexpected side-effects, which may render code dysfunctional and may destroy portability. Reflective code breaks abstractions and therefore may change behavior with upgrades of the platform.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="异常">异常<a href="#异常" class="hash-link" aria-label="异常的直接链接" title="异常的直接链接">​</a></h3>
<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种: <strong>Error</strong> 和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种:</p>
<ul>
<li><strong>受检异常</strong> : 需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> : 是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="泛型">泛型<a href="#泛型" class="hash-link" aria-label="泛型的直接链接" title="泛型的直接链接">​</a></h3>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Box&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // T stands for &quot;Type&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T t;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void set(T t) { this.t = t; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T get() { return t; }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="注解">注解<a href="#注解" class="hash-link" aria-label="注解的直接链接" title="注解的直接链接">​</a></h3>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="特性">特性<a href="#特性" class="hash-link" aria-label="特性的直接链接" title="特性的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-各版本的新特性">Java 各版本的新特性<a href="#java-各版本的新特性" class="hash-link" aria-label="Java 各版本的新特性的直接链接" title="Java 各版本的新特性的直接链接">​</a></h4>
<p><strong>New highlights in Java SE 8</strong></p>
<ol>
<li>Lambda Expressions</li>
<li>Pipelines and Streams</li>
<li>Date and Time API</li>
<li>Default Methods</li>
<li>Type Annotations</li>
<li>Nashhorn JavaScript Engine</li>
<li>Concurrent Accumulators</li>
<li>Parallel operations</li>
<li>PermGen Error Removed</li>
</ol>
<p><strong>New highlights in Java SE 7</strong></p>
<ol>
<li>Strings in Switch Statement</li>
<li>Type Inference for Generic Instance Creation</li>
<li>Multiple Exception Handling</li>
<li>Support for Dynamic Languages</li>
<li>Try with Resources</li>
<li>Java nio Package</li>
<li>Binary Literals, Underscore in literals</li>
<li>Diamond Syntax</li>
</ol>
<ul>
<li><a href="http://www.selfgrowth.com/articles/difference-between-java-18-and-java-17" target="_blank" rel="noopener noreferrer">Difference between Java 1.8 and Java 1.7?在新窗口打开</a></li>
<li><a href="http://www.importnew.com/19345.html" target="_blank" rel="noopener noreferrer">Java 8 特性在新窗口打开</a></li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-与-c-的区别">Java 与 C++ 的区别<a href="#java-与-c-的区别" class="hash-link" aria-label="Java 与 C++ 的区别的直接链接" title="Java 与 C++ 的区别的直接链接">​</a></h4>
<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象支持加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>
<p><a href="http://cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php" target="_blank" rel="noopener noreferrer">What are the main differences between Java and C++?在新窗口打开</a></p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="jre-or-jdk">JRE or JDK<a href="#jre-or-jdk" class="hash-link" aria-label="JRE or JDK的直接链接" title="JRE or JDK的直接链接">​</a></h4>
<ul>
<li>JRE is the JVM program, Java application need to run on JRE.</li>
<li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &quot;javac&quot;</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_Donx" id="java-基础---图谱--qa">Java 基础 - 图谱 &amp; Q/A<a href="#java-基础---图谱--qa" class="hash-link" aria-label="Java 基础 - 图谱 &amp; Q/A的直接链接" title="Java 基础 - 图谱 &amp; Q/A的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="知识体系">知识体系<a href="#知识体系" class="hash-link" aria-label="知识体系的直接链接" title="知识体系的直接链接">​</a></h3>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java_basic-39c915f0d84a2f97cb7954abb0529146.png" width="1615" height="1982" class="img__I0M"></p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="qa">Q&amp;A<a href="#qa" class="hash-link" aria-label="Q&amp;A的直接链接" title="Q&amp;A的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中应该使用什么数据类型来代表价格">Java 中应该使用什么数据类型来代表价格?<a href="#java-中应该使用什么数据类型来代表价格" class="hash-link" aria-label="Java 中应该使用什么数据类型来代表价格?的直接链接" title="Java 中应该使用什么数据类型来代表价格?的直接链接">​</a></h4>
<p>如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="怎么将-byte-转换为-string">怎么将 byte 转换为 String?<a href="#怎么将-byte-转换为-string" class="hash-link" aria-label="怎么将 byte 转换为 String?的直接链接" title="怎么将 byte 转换为 String?的直接链接">​</a></h4>
<p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中怎样将-bytes-转换为-long-类型">Java 中怎样将 bytes 转换为 long 类型?<a href="#java-中怎样将-bytes-转换为-long-类型" class="hash-link" aria-label="Java 中怎样将 bytes 转换为 long 类型?的直接链接" title="Java 中怎样将 bytes 转换为 long 类型?的直接链接">​</a></h4>
<p>String接收bytes的构造器转成String，再Long.parseLong</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围将会出现什么现象">我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?<a href="#我们能将-int-强制转换为-byte-类型的变量吗-如果该值大于-byte-类型的范围将会出现什么现象" class="hash-link" aria-label="我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?的直接链接" title="我们能将 int 强制转换为 byte 类型的变量吗? 如果该值大于 byte 类型的范围，将会出现什么现象?的直接链接">​</a></h4>
<p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="存在两个类b-继承-ac-继承-b我们能将-b-转换为-c-么-如-c--c-b">存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；<a href="#存在两个类b-继承-ac-继承-b我们能将-b-转换为-c-么-如-c--c-b" class="hash-link" aria-label="存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；的直接链接" title="存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么? 如 C = (C) B；的直接链接">​</a></h4>
<p>可以，向下转型。但是不建议使用，容易出现类型转型异常.</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="哪个类包含-clone-方法-是-cloneable-还是-object">哪个类包含 clone 方法? 是 Cloneable 还是 Object?<a href="#哪个类包含-clone-方法-是-cloneable-还是-object" class="hash-link" aria-label="哪个类包含 clone 方法? 是 Cloneable 还是 Object?的直接链接" title="哪个类包含 clone 方法? 是 Cloneable 还是 Object?的直接链接">​</a></h4>
<p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中--操作符是线程安全的吗">Java 中 ++ 操作符是线程安全的吗?<a href="#java-中--操作符是线程安全的吗" class="hash-link" aria-label="Java 中 ++ 操作符是线程安全的吗?的直接链接" title="Java 中 ++ 操作符是线程安全的吗?的直接链接">​</a></h4>
<p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。还会存在竞态条件(读取-修改-写入)。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="a--a--b-与-a--b-的区别">a = a + b 与 a += b 的区别<a href="#a--a--b-与-a--b-的区别" class="hash-link" aria-label="a = a + b 与 a += b 的区别的直接链接" title="a = a + b 与 a += b 的区别的直接链接">​</a></h4>
<p>+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">byte a = 127;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">byte b = 127;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b = a + b; // error : cannot convert from int to byte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">b += a; // ok</span><br></span></code></pre></div></div>
<p>(因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错)</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗">我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?<a href="#我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗" class="hash-link" aria-label="我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?的直接链接" title="我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗?的直接链接">​</a></h4>
<p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="301--03-将会返回什么-true-还是-false">3*0.1 == 0.3 将会返回什么? true 还是 false?<a href="#301--03-将会返回什么-true-还是-false" class="hash-link" aria-label="3*0.1 == 0.3 将会返回什么? true 还是 false?的直接链接" title="3*0.1 == 0.3 将会返回什么? true 还是 false?的直接链接">​</a></h4>
<p>false，因为有些浮点数不能完全精确的表示出来。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="int-和-integer-哪个会占用更多的内存">int 和 Integer 哪个会占用更多的内存?<a href="#int-和-integer-哪个会占用更多的内存" class="hash-link" aria-label="int 和 Integer 哪个会占用更多的内存?的直接链接" title="int 和 Integer 哪个会占用更多的内存?的直接链接">​</a></h4>
<p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="为什么-java-中的-string-是不可变的immutable">为什么 Java 中的 String 是不可变的(Immutable)?<a href="#为什么-java-中的-string-是不可变的immutable" class="hash-link" aria-label="为什么 Java 中的 String 是不可变的(Immutable)?的直接链接" title="为什么 Java 中的 String 是不可变的(Immutable)?的直接链接">​</a></h4>
<p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="我们能在-switch-中使用-string-吗">我们能在 Switch 中使用 String 吗?<a href="#我们能在-switch-中使用-string-吗" class="hash-link" aria-label="我们能在 Switch 中使用 String 吗?的直接链接" title="我们能在 Switch 中使用 String 吗?的直接链接">​</a></h4>
<p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中的构造器链是什么">Java 中的构造器链是什么?<a href="#java-中的构造器链是什么" class="hash-link" aria-label="Java 中的构造器链是什么?的直接链接" title="Java 中的构造器链是什么?的直接链接">​</a></h4>
<p>当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="枚举类">枚举类<a href="#枚举类" class="hash-link" aria-label="枚举类的直接链接" title="枚举类的直接链接">​</a></h4>
<p>JDK1.5出现 每个枚举值都需要调用一次构造函数</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="什么是不可变对象immutable-object-java-中怎么创建一个不可变对象">什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?<a href="#什么是不可变对象immutable-object-java-中怎么创建一个不可变对象" class="hash-link" aria-label="什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?的直接链接" title="什么是不可变对象(immutable object)? Java 中怎么创建一个不可变对象?的直接链接">​</a></h4>
<p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。</p>
<p>如何在Java中写出Immutable的类?</p>
<p>要写出这样的类，需要遵循以下几个原则:</p>
<p>1)immutable对象的状态在创建之后就不能发生改变，任何对它的改变都应该产生一个新的对象。</p>
<p>2)Immutable类的所有的属性都应该是final的。</p>
<p>3)对象必须被正确的创建，比如: 对象引用在对象创建过程中不能泄露(leak)。</p>
<p>4)对象应该是final的，以此来限制子类继承父类，以避免子类改变了父类的immutable特性。</p>
<p>5)如果类中包含mutable类对象，那么返回给客户端的时候，返回该对象的一个拷贝，而不是该对象本身(该条可以归为第一条中的一个特例)</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="我们能创建一个包含可变对象的不可变对象吗">我们能创建一个包含可变对象的不可变对象吗?<a href="#我们能创建一个包含可变对象的不可变对象吗" class="hash-link" aria-label="我们能创建一个包含可变对象的不可变对象吗?的直接链接" title="我们能创建一个包含可变对象的不可变对象吗?的直接链接">​</a></h4>
<p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="有没有可能两个不相等的对象有相同的-hashcode">有没有可能两个不相等的对象有相同的 hashcode?<a href="#有没有可能两个不相等的对象有相同的-hashcode" class="hash-link" aria-label="有没有可能两个不相等的对象有相同的 hashcode?的直接链接" title="有没有可能两个不相等的对象有相同的 hashcode?的直接链接">​</a></h4>
<p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="两个相同的对象会有不同的-hash-code-吗">两个相同的对象会有不同的 hash code 吗?<a href="#两个相同的对象会有不同的-hash-code-吗" class="hash-link" aria-label="两个相同的对象会有不同的 hash code 吗?的直接链接" title="两个相同的对象会有不同的 hash code 吗?的直接链接">​</a></h4>
<p>不能，根据 hash code 的规定，这是不可能的。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="我们可以在-hashcode-中使用随机数字吗">我们可以在 hashcode() 中使用随机数字吗?<a href="#我们可以在-hashcode-中使用随机数字吗" class="hash-link" aria-label="我们可以在 hashcode() 中使用随机数字吗?的直接链接" title="我们可以在 hashcode() 中使用随机数字吗?的直接链接">​</a></h4>
<p>不行，因为对象的 hashcode 值必须是相同的。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中comparator-与-comparable-有什么不同">Java 中，Comparator 与 Comparable 有什么不同?<a href="#java-中comparator-与-comparable-有什么不同" class="hash-link" aria-label="Java 中，Comparator 与 Comparable 有什么不同?的直接链接" title="Java 中，Comparator 与 Comparable 有什么不同?的直接链接">​</a></h4>
<p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="为什么在重写-equals-方法的时候需要重写-hashcode-方法">为什么在重写 equals 方法的时候需要重写 hashCode 方法?<a href="#为什么在重写-equals-方法的时候需要重写-hashcode-方法" class="hash-link" aria-label="为什么在重写 equals 方法的时候需要重写 hashCode 方法?的直接链接" title="为什么在重写 equals 方法的时候需要重写 hashCode 方法?的直接链接">​</a></h4>
<p>因为有强制的规范指定需要同时重写 hashcode 与 equals 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="ab和aequalsb有什么区别">“a==b”和”a.equals(b)”有什么区别?<a href="#ab和aequalsb有什么区别" class="hash-link" aria-label="“a==b”和”a.equals(b)”有什么区别?的直接链接" title="“a==b”和”a.equals(b)”有什么区别?的直接链接">​</a></h4>
<p>如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="ahashcode-有什么用-与-aequalsb-有什么关系">a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?<a href="#ahashcode-有什么用-与-aequalsb-有什么关系" class="hash-link" aria-label="a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?的直接链接" title="a.hashCode() 有什么用? 与 a.equals(b) 有什么关系?的直接链接">​</a></h4>
<p>简介: hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equals() 方法来判断相等的对象，必须具有相同的 hash code。</p>
<p>1、hashcode的作用</p>
<p>List和Set，如何保证Set不重复呢? 通过迭代使用equals方法来判断，数据量小还可以接受，数据量大怎么解决? 引入hashcode，实际上hashcode扮演的角色就是寻址，大大减少查询匹配次数。</p>
<p>2、hashcode重要吗</p>
<p>对于数组、List集合就是一个累赘。而对于hashmap, hashset, hashtable就异常重要了。</p>
<p>3、equals方法遵循的原则</p>
<ul>
<li>对称性 若x.equals(y)true，则y.equals(x)true</li>
<li>自反性 x.equals(x)必须true</li>
<li>传递性 若x.equals(y)true,y.equals(z)true,则x.equals(z)必为true</li>
<li>一致性 只要x,y内容不变，无论调用多少次结果不变</li>
<li>其他 x.equals(null) 永远false，x.equals(和x数据类型不同)始终false</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="finalfinalize-和-finally-的不同之处">final、finalize 和 finally 的不同之处?<a href="#finalfinalize-和-finally-的不同之处" class="hash-link" aria-label="final、finalize 和 finally 的不同之处?的直接链接" title="final、finalize 和 finally 的不同之处?的直接链接">​</a></h4>
<ul>
<li>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。</li>
<li>Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。</li>
<li>finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中的编译期常量是什么-使用它又什么风险">Java 中的编译期常量是什么? 使用它又什么风险?<a href="#java-中的编译期常量是什么-使用它又什么风险" class="hash-link" aria-label="Java 中的编译期常量是什么? 使用它又什么风险?的直接链接" title="Java 中的编译期常量是什么? 使用它又什么风险?的直接链接">​</a></h4>
<p>变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="静态内部类与顶级类有什么区别">静态内部类与顶级类有什么区别?<a href="#静态内部类与顶级类有什么区别" class="hash-link" aria-label="静态内部类与顶级类有什么区别?的直接链接" title="静态内部类与顶级类有什么区别?的直接链接">​</a></h4>
<p>一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中serializable-与-externalizable-的区别">Java 中，Serializable 与 Externalizable 的区别?<a href="#java-中serializable-与-externalizable-的区别" class="hash-link" aria-label="Java 中，Serializable 与 Externalizable 的区别?的直接链接" title="Java 中，Serializable 与 Externalizable 的区别?的直接链接">​</a></h4>
<p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="说出-jdk-17-中的三个新特性">说出 JDK 1.7 中的三个新特性?<a href="#说出-jdk-17-中的三个新特性" class="hash-link" aria-label="说出 JDK 1.7 中的三个新特性?的直接链接" title="说出 JDK 1.7 中的三个新特性?的直接链接">​</a></h4>
<p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符<code>(&lt;&gt;)</code>用于泛型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="说出-5-个-jdk-18-引入的新特性">说出 5 个 JDK 1.8 引入的新特性?<a href="#说出-5-个-jdk-18-引入的新特性" class="hash-link" aria-label="说出 5 个 JDK 1.8 引入的新特性?的直接链接" title="说出 5 个 JDK 1.8 引入的新特性?的直接链接">​</a></h4>
<p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性: Lambda 表达式，允许像对象一样传递匿名函数 Stream API，充分利用现代多核 CPU，可以写出很简洁的代码 Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用 扩展方法，现在，接口中可以有静态、默认方法。 重复注解，现在你可以将相同的注解在同一类型上使用多次。</p>
<p>下述包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="接口是什么-为什么要使用接口而不是直接使用具体类">接口是什么? 为什么要使用接口而不是直接使用具体类?<a href="#接口是什么-为什么要使用接口而不是直接使用具体类" class="hash-link" aria-label="接口是什么? 为什么要使用接口而不是直接使用具体类?的直接链接" title="接口是什么? 为什么要使用接口而不是直接使用具体类?的直接链接">​</a></h4>
<p>接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许普通方法，以此来保证抽象，但是 Java 8 中你可以在接口声明静态方法和默认普通方法。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java-中抽象类与接口之间有什么不同">Java 中，抽象类与接口之间有什么不同?<a href="#java-中抽象类与接口之间有什么不同" class="hash-link" aria-label="Java 中，抽象类与接口之间有什么不同?的直接链接" title="Java 中，抽象类与接口之间有什么不同?的直接链接">​</a></h4>
<p>Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制 参见第六条。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="object有哪些公用方法">Object有哪些公用方法?<a href="#object有哪些公用方法" class="hash-link" aria-label="Object有哪些公用方法?的直接链接" title="Object有哪些公用方法?的直接链接">​</a></h4>
<p>clone equals hashcode wait notify notifyall finalize toString getClass 除了clone和finalize其他均为公共方法。</p>
<p>11个方法，wait被重载了两次</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="equals与的区别">equals与==的区别<a href="#equals与的区别" class="hash-link" aria-label="equals与==的区别的直接链接" title="equals与==的区别的直接链接">​</a></h4>
<p>区别1. ==是一个运算符 equals是Object类的方法</p>
<p>区别2. 比较时的区别</p>
<ul>
<li>用于基本类型的变量比较时: ==用于比较值是否相等，equals不能直接用于基本数据类型的比较，需要转换为其对应的包装类型。</li>
<li>用于引用类型的比较时。==和equals都是比较栈内存中的地址是否相等 。相等为true 否则为false。但是通常会重写equals方法去实现对象内容的比较。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="stringstringbuffer与stringbuilder的区别">String、StringBuffer与StringBuilder的区别<a href="#stringstringbuffer与stringbuilder的区别" class="hash-link" aria-label="String、StringBuffer与StringBuilder的区别的直接链接" title="String、StringBuffer与StringBuilder的区别的直接链接">​</a></h4>
<p>第一点: 可变和适用范围。String对象是不可变的，而StringBuffer和StringBuilder是可变字符序列。每次对String的操作相当于生成一个新的String对象，而对StringBuffer和StringBuilder的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用String，因为频繁的生成对象将会对系统性能产生影响。</p>
<p>第二点: 线程安全。String由于有final修饰，是immutable的，安全性是简单而纯粹的。StringBuilder和StringBuffer的区别在于StringBuilder不保证同步，也就是说如果需要线程安全需要使用StringBuffer，不需要同步的StringBuilder效率更高。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="switch能否用string做参数">switch能否用String做参数<a href="#switch能否用string做参数" class="hash-link" aria-label="switch能否用String做参数的直接链接" title="switch能否用String做参数的直接链接">​</a></h4>
<p>Java1.7开始支持，但实际这是一颗Java语法糖。除此之外，byte，short，int，枚举均可用于switch，而boolean和浮点型不可以。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="接口与抽象类">接口与抽象类<a href="#接口与抽象类" class="hash-link" aria-label="接口与抽象类的直接链接" title="接口与抽象类的直接链接">​</a></h4>
<ul>
<li>一个子类只能继承一个抽象类, 但能实现多个接口</li>
<li>抽象类可以有构造方法, 接口没有构造方法</li>
<li>抽象类可以有普通成员变量, 接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量, 抽象类中静态成员变量访问类型任意，接口只能public static final(默认)</li>
<li>抽象类可以没有抽象方法, 抽象类可以有普通方法；接口在JDK8之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li>
<li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li>
<li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="抽象类和最终类">抽象类和最终类<a href="#抽象类和最终类" class="hash-link" aria-label="抽象类和最终类的直接链接" title="抽象类和最终类的直接链接">​</a></h4>
<p>抽象类可以没有抽象方法, 最终类可以没有最终方法</p>
<p>最终类不能被继承, 最终方法不能被重写(可以重载)</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常-1">异常<a href="#异常-1" class="hash-link" aria-label="异常的直接链接" title="异常的直接链接">​</a></h4>
<p>相关的关键字 throw、throws、try...catch、finally</p>
<ul>
<li>throws 用在方法签名上, 以便抛出的异常可以被调用者处理</li>
<li>throw 方法内部通过throw抛出异常</li>
<li>try 用于检测包住的语句块, 若有异常, catch子句捕获并执行catch块</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="关于finally">关于finally<a href="#关于finally" class="hash-link" aria-label="关于finally的直接链接" title="关于finally的直接链接">​</a></h4>
<ul>
<li>finally不管有没有异常都要处理</li>
<li>当try和catch中有return时，finally仍然会执行，finally比return先执行</li>
<li>不管有木有异常抛出, finally在return返回前执行</li>
<li>finally是在return后面的表达式运算后执行的(此时并没有返回运算后的值，而是先把要返回的值保存起来，管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值)，所以函数返回值是在finally执行前确定的</li>
</ul>
<p>注意: finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值</p>
<p>finally不执行的几种情况: 程序提前终止如调用了System.exit, 病毒，断电</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="受检查异常和运行时异常">受检查异常和运行时异常<a href="#受检查异常和运行时异常" class="hash-link" aria-label="受检查异常和运行时异常的直接链接" title="受检查异常和运行时异常的直接链接">​</a></h4>
<ul>
<li>受检查的异常(checked exceptions),其必须被try...catch语句块所捕获, 或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查, Java虚拟机也要进行检查, 以确保这个规则得到遵守。</li>
</ul>
<p>常见的checked exception: ClassNotFoundException IOException FileNotFoundException EOFException</p>
<ul>
<li>运行时异常(runtime exceptions), 需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除...</li>
</ul>
<p>常见的runtime exception: NullPointerException ArithmeticException ClassCastException IllegalArgumentException IllegalStateException IndexOutOfBoundsException NoSuchElementException</p>
<ul>
<li>Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕获。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="super出现在父类的子类中有三种存在方式">super出现在父类的子类中。有三种存在方式<a href="#super出现在父类的子类中有三种存在方式" class="hash-link" aria-label="super出现在父类的子类中。有三种存在方式的直接链接" title="super出现在父类的子类中。有三种存在方式的直接链接">​</a></h4>
<ul>
<li>super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用</li>
<li>super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法</li>
<li>super() 调用父类构造</li>
</ul>
<p>注: super只能指代其直接父类</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="this--super在构造方法中的区别">this() &amp; super()在构造方法中的区别<a href="#this--super在构造方法中的区别" class="hash-link" aria-label="this() &amp; super()在构造方法中的区别的直接链接" title="this() &amp; super()在构造方法中的区别的直接链接">​</a></h4>
<ul>
<li>调用super()必须写在子类构造方法的第一行, 否则编译不通过</li>
<li>super从子类调用父类构造, this在同一类中调用其他构造均需要放在第一行</li>
<li>尽管可以用this调用一个构造器, 却不能调用2个</li>
<li>this和super不能出现在同一个构造器中, 否则编译不通过</li>
<li>this()、super()都指的对象,不可以在static环境中使用</li>
<li>本质this指向本对象的指针。super是一个关键字</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="构造内部类和静态内部类对象">构造内部类和静态内部类对象<a href="#构造内部类和静态内部类对象" class="hash-link" aria-label="构造内部类和静态内部类对象的直接链接" title="构造内部类和静态内部类对象的直接链接">​</a></h4>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Enclosingone {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public class Insideone {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public static class Insideone{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// 构造内部类对象需要外部类的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Enclosingone.Insideone obj1 = new Enclosingone().new Insideone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	// 构造静态内部类的对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	Enclosingone.Insideone obj2 = new Enclosingone.Insideone();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>静态内部类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。非静态内部类能够访问外部类的静态和非静态成员。静态内部类不能访问外部类的非静态成员，只能访问外部类的静态成员。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="序列化">序列化<a href="#序列化" class="hash-link" aria-label="序列化的直接链接" title="序列化的直接链接">​</a></h4>
<p>声明为static和transient类型的数据不能被序列化， 反序列化需要一个无参构造函数</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java移位运算符">Java移位运算符<a href="#java移位运算符" class="hash-link" aria-label="Java移位运算符的直接链接" title="Java移位运算符的直接链接">​</a></h4>
<p>java中有三种移位运算符</p>
<ul>
<li><code>&lt;&lt;</code> :左移运算符,<code>x &lt;&lt; 1</code>,相当于x乘以2(不溢出的情况下),低位补0</li>
<li><code>&gt;&gt;</code> :带符号右移,<code>x &gt;&gt; 1</code>,相当于x除以2,正数高位补0,负数高位补1</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移,忽略符号位,空位都以0补齐</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="形参实参">形参&amp;实参<a href="#形参实参" class="hash-link" aria-label="形参&amp;实参的直接链接" title="形参&amp;实参的直接链接">​</a></h4>
<p>形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是: 方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值(指针、引用皆在此列)，也就是说真正被传递的是实参。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="局部变量为什么要初始化">局部变量为什么要初始化<a href="#局部变量为什么要初始化" class="hash-link" aria-label="局部变量为什么要初始化的直接链接" title="局部变量为什么要初始化的直接链接">​</a></h4>
<p>局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java语言的鲁棒性">Java语言的鲁棒性<a href="#java语言的鲁棒性" class="hash-link" aria-label="Java语言的鲁棒性的直接链接" title="Java语言的鲁棒性的直接链接">​</a></h4>
<p>Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的异常，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。</p>
<h2 class="anchor anchorWithStickyNavbar_Donx" id="java-基础---泛型机制详解">Java 基础 - 泛型机制详解<a href="#java-基础---泛型机制详解" class="hash-link" aria-label="Java 基础 - 泛型机制详解的直接链接" title="Java 基础 - 泛型机制详解的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="为什么会引入泛型">为什么会引入泛型<a href="#为什么会引入泛型" class="hash-link" aria-label="为什么会引入泛型的直接链接" title="为什么会引入泛型的直接链接">​</a></h3>
<blockquote>
<p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<p>引入泛型的意义在于：</p>
<ul>
<li><strong>适用于多种数据类型执行相同的代码</strong>（代码复用）</li>
</ul>
<p>我们通过一个例子来阐述，先看下下面的代码：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static int add(int a, int b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static float add(float a, float b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static double add(double a, double b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a + b));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static &lt;T extends Number&gt; double add(T a, T b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(a + &quot;+&quot; + b + &quot;=&quot; + (a.doubleValue() + b.doubleValue()));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a.doubleValue() + b.doubleValue();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>泛型中的类型在使用时指定，不需要强制类型转换（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</li>
</ul>
<p>看下这个例子：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">List list = new ArrayList();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(&quot;xxString&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(100d);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list.add(new Person());</span><br></span></code></pre></div></div>
<p>我们在使用上述list中，list中的元素都是Object类型（无法约束其中的类型），所以在取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现<code>java.lang.ClassCastException</code>异常。</p>
<p>引入泛型，它将提供类型的约束，提供编译前的检查：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// list中只能放String, 不能放其它类型的元素</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="泛型的基本使用">泛型的基本使用<a href="#泛型的基本使用" class="hash-link" aria-label="泛型的基本使用的直接链接" title="泛型的基本使用的直接链接">​</a></h3>
<p>提示</p>
<p>我们通过一些例子来学习泛型的使用；泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。一些例子可以参考《李兴华 - Java实战经典》。@pdai</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型类">泛型类<a href="#泛型类" class="hash-link" aria-label="泛型类的直接链接" title="泛型类的直接链接">​</a></h4>
<ul>
<li>从一个简单的泛型类看起：</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Point&lt;T&gt;{         // 此处可以随便写标识符号，T是type的简称  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T var ;     // var的类型由T指定，即：由外部指定  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getVar(){  // 返回值的类型由外部决定  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return var ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setVar(T var){  // 设置的类型也由外部决定  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.var = var ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsDemo06{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Point&lt;String&gt; p = new Point&lt;String&gt;() ;     // 里面的var类型为String类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        p.setVar(&quot;it&quot;) ;                            // 设置字符串  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(p.getVar().length()) ;   // 取得字符串的长度  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>多元泛型</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Notepad&lt;K,V&gt;{       // 此处指定了两个泛型类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private K key ;     // 此变量的类型由外部决定  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private V value ;   // 此变量的类型由外部决定  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public K getKey(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.key ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public V getValue(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.value ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setKey(K key){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.key = key ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(V value){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsDemo09{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Notepad&lt;String,Integer&gt; t = null ;        // 定义两个泛型类型的对象  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t = new Notepad&lt;String,Integer&gt;() ;       // 里面的key为String，value为Integer  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.setKey(&quot;汤姆&quot;) ;        // 设置第一个内容  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.setValue(20) ;            // 设置第二个内容  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;姓名；&quot; + t.getKey()) ;      // 取得信息  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;，年龄；&quot; + t.getValue()) ;       // 取得信息  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型接口">泛型接口<a href="#泛型接口" class="hash-link" aria-label="泛型接口的直接链接" title="泛型接口的直接链接">​</a></h4>
<ul>
<li>简单的泛型接口</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">interface Info&lt;T&gt;{        // 在接口上定义泛型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getVar() ; // 定义抽象方法，抽象方法的返回值就是泛型类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class InfoImpl&lt;T&gt; implements Info&lt;T&gt;{   // 定义泛型接口的子类  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T var ;             // 定义属性  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public InfoImpl(T var){     // 通过构造方法设置属性内容  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.setVar(var) ;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setVar(T var){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.var = var ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getVar(){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.var ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsDemo24{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String arsg[]){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Info&lt;String&gt; i = null;        // 声明接口对象  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i = new InfoImpl&lt;String&gt;(&quot;汤姆&quot;) ;  // 通过子类实例化对象  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;内容：&quot; + i.getVar()) ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型方法">泛型方法<a href="#泛型方法" class="hash-link" aria-label="泛型方法的直接链接" title="泛型方法的直接链接">​</a></h4>
<p>泛型方法，是在调用方法的时候指明泛型的具体类型。重点看下泛型的方法（图参考自：<a href="https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html%EF%BC%89" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/iyangyuan/archive/2013/04/09/3011274.html）</a></p>
<ul>
<li>
<p>定义泛型方法语法格式</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-generic-4-0e34d85b90c43115ff6a0040f3f38f89.png" width="1199" height="543" class="img__I0M"></p>
</li>
<li>
<p>调用泛型方法语法格式</p>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA7YAAAD4CAMAAADvnoorAAAAxlBMVEX/////AADx7+LAwMEAAAClYAAAgAAxasVkZGTc//+0ALX//9//5aP//7+////EbwDo///enD7/v3QCAHScSAAASJyrm8xPndxmwPScY2ub3/0An6UAAEgAdL9fgAD/1XOr6/pIAADvuZz//9F0AADV5v+alwBngbj//+gGgHGe0f7/0Z/xt0jHy/9z1/uCuOW6gmUHgUakYEjfxEfxmr3RcsKmgZ+9rgDFRsKKZJxkZJ742dJkZIPr3ZD///NISD//6OgAdHSjrBIDAAAZh0lEQVR4nO2dDV/bthbGZZzQ2+A0OOuAtoNA4LasQMtW+rJ27Xa//5e6etc5sgzOG0mV5/8bxXFkxdLR43OOpDAhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADYPKqz314KcF8/3B3w3wCsm7rXOxQrpOr3S/ET0N4Pd4PBvvr948sAugXLQw65Xu/Xp3Ndu2pve93vf9oXj8NK+uHb4KM7/Di4EQAsheqspzkWm8jjedvV9MOl9bXxMQCLMLzo/fJM/h5vpmx/9n64ox52ijAZLIcRcy/a5Rypo3HvSL3QQ5me33v+69Nxz2Rye89ZVKmCTFueIuNcjRq/lTo4MGc/7Y3sWXp+OOrfqFcqNB6O/Gldv3zx5387tqul/trF3HX/4BH64XLwhThYmd66V9/gecH8DC9oTlaHOHHc+6fncz1yXg7Xvn5xGA1X6a5SMabWjpOtVfCL/SBmrUNyXkq17FuRMdlWoQzl48AS6bml/msr2x81D75X1A+Rfw2+V942El0wL9WZHG56pB2rF8pJ7D1XI3isPYYZzfS8GqLH6m0zTJXTMTWNtIcZvok+YGL1quRWaQ2adFUpqQxn/HklVVm2tvqUL83AV/KXFe3dziDbRP0TW6+s7uYR+uGOizOoGN4WLEB1diz8cK2Nx6nODv14rFVISM+bQeuHqR+uw4v0HOxEu7dKez2rRR2oXjuRHvDz8oxxxiYc9rKdzDg31VJ/JQ+Hoz//q34eoR8+8qfJv2FaGYD50V5GqNF2rBxFz0eBY7MOqYcrPb/3nKWvfriOW9YtibcN8bKOVpVutKzYea9Tg3953T2tJeUb9Su5qifAcMSj7RX1QyTbS8gWLIPhhRl9K5Ot00wpViPb9iA5Wb8Kjuvb0acqWg5eUT9Esv0G2YJlIFM0PczMcCXTMmy4kvNtw9W5q5gqTCOHaVzBZMXOt8m2LUjuIFtWv5yKGh3Uf36PJpJX1A+tuS0AizA2k556uI7J+g0drvR823CV414dNaakrok+JnZauL7hsqLn22Q7bJmSaqOlfjmDfNu/mch/Dh6jH1pnkr9hJhksQh0CPxcFmhnUMFzpeTpcx/ZSfcbuMooXgNxCzCczKUTWgoKs6HkqW3etvniSXgBqo63+a5PhNn33SvqBb4wi67Z3A7aiC8CMmIVG4yzG6eFKzrcO13jTgaPuE71NyFIqkRU53ypbs4o7w3aLdP3G89b9/s2j9EPbLimpYKwAgU1lb+Q2Rc02EbxifohHonVP8h28LdhYzE4Hpd6Nku3jMQ3ypN8AkrktZqfAphIWX36Kr82ugNT3baVo4WzBJnM900xShiT+ugXmkQEAAAAAAAAAAAAAAAAAAAAAAIDt4jLaKTA9TRY7b9sWNf1Kv25wfs9fL7+8fYOtRADMwtV/1Hdfqr+cyM5fvNe/L2//E/FWn5/a34rqhT9N6jMnxm/4H197EWmz9hde3h5s50ZmAObmXAlKC9ByoPV1eWvkOz20pZzKtC7PdXmtxB191ldwKMr9q79PxVUk02mbvv0nAQASnBOXF46n8uBceVvtcp0+nZjGsWzVGyoCruL9tlfqpPbaV3+/bcj20kXTU/uGqvHbvoBsAbiXK+Lxrpj3c7Kdvo9l2/C2nlr6VFZ7kK080rJtRtoKn/Wel+T9qDYAgILO/UTzQOd/fddR7vvpqdNnnfC2dmbp6jRRhZOtjIa9bEP9L5hHPTdfk5k+JZ90iW/LANAk7WwrJchmkCznjBIzUpWSn4t3SZh8HnLj96JMyfZtdCvvvXjdAwIA0KQmazL2WGnzK5GtnEyKvG0UJCu5G2drXwbJqaQ1CpI91V/mmvMbcqFbU4JsAWijIoEqOdb6Ov9LZplvzl8cymz03tz28vb08oD41r8PTm09+gIr20MRyfaKOGNb+q1fy7Wy3REAgAg6hUSOjWxfnP4bJngVrTPJ4sofsexWK/bKO/Qpk619dXlL/pj/9O2Uh+HYdQFAhHSlyWMnW7Pyehhka7dXNBaAPj1N1KJqEE622htTEbpnAJ2ZOnc7PKbOA/8L2QLAmRJnS4+1bKWrVN5S/jh9kkCYbpKS5Z3y2OywFfPV19Jo74qt57hNWBWZmZq+d9W8wSYpAJKkt1oIJ9s3+w3ZnurfNrz13tad55PDbsqJ+E6Km3QiYvZX1IiNAWihdauFlO3V1++HIpKtdZA/mGzV9gmrsrCLmWPKe3Gbj3AZr/9+Qe3r0e+FwBsA4GnfanH1pj4U9Vuzq/irl63NaWNv6yaVprGPvIo2Qt2e+reCholnrU09Vv3RdgwAgOALrFcsjr2Sfk9ND1VMn5dWdj8aslXXVu0qa+jZT26xiWR76Oel8O09ABoktlpYrqRypmSC1+jTTzxFslWCVV/Cm7ZtIW7I1vhavc+CzEiZWWgVNF9h/QeAJC1bLSxul6GYuiljf0Z5W/OFACfbQ/Fvyb8lwP4H81629uHg8tqafYnAyFbPVrur+ffqAQAtWy0MdELIBK+NKaKHcs+wceK9++btWyX9ii4Qc30DAAAAAAAAAAAAAAAAAABsBjsrQPxsFLMhAFgvkK2AbFfRSWCzgWy3gwLkRB6yXUnZrChATkC228HWNnwTWTCNhWy3Bsh2g8hStuPerzN9+abLiHR15jB6Z+0fcXfwczT87kBsB3NI9e5gw2Q77kXfxBn1fns5SwWJEdla5+pHb9Xvl0utcOH+uRsM9qOG7z3v9WYVv4iv7x2JpaLvUzLZ/eN0eLK7zNonpLa917u7u6/W+q3MbkqV/fCykv2gX3wZHGyCbMfK7ofm6DB+64EBVfMB00W2j+dtr/v9T3N+wZ62a3n9823w0TVcV3osFpbt8KJ3v2xHvV+e6XIzfIa5T0l18vszqa13YnksT7YfOtxXssze69+f6b47efW0m2y/n/x+uiP7wbz6OCiJbMv1yHak7a5HTmNYPsgcsr2n7JJZwNuSdi2vfy6ND5MNt2LTulXKnV+2ta2jlZF55MwiW3ufYuWyVW1//fPJdmcwILIdrEW2Yx3nyXF0nJ1sFyC0a4n9cze4sQ1/blzgeHHZjnRF9xX47R9VZBbZ2vsUSravnkK2Sravdohspz5MVrI9WINs956b7Gx4IY0rh2V11rNDyvgDOyrUaT8Ca3veFvGFiBRZYJmus5NsZZyr0X9vSh0cmLOf9kb2LD0/HPVv1CsVGg9H/rS+Z/niz+YfS7d3pPvAt5G2a4n9czn4sm8bzqNiIts6+GDSh/yYQWQbyqgKx/bF6Lfy7NDL1tc/vDisZbPH9gp6/+4+hRnY4vMfp+bVBxnSmgEvxSc50iWOPsgEeLKbSIB9+cnuO5kZuuMjfyyYbH2d7nh3V38yPe+xBVxFqkqnUF8+KhP6m8vWlHf6VPXow9ev9Dv6jUrJ9vMfL50wvwyCbP3xzjfrhcXqqc7sIBnJ4Tnu/eOHGRuWNYnpbIB3fJ9sWWDZUieR7ceBJdKV1qaTrVXwi/0gZq1Dcl5KtexbtTLZVqEMH/S9INvQRtquJfaPfEa7TuIxSpDtiNRjj4/iY2o79wHqetLnssJ+z4pY3vdz+flGtqH+4YVqyv8uzM3R+/f3GTE80RJ4pY4/GzlIxQ1P/lAHJw1t0PJyRseV98e2eJBtqNMfa9na48hrckl+2G3c27uusnXlleBcPUa2r3eJoBl3LruVtvTHMuc1h2L1+LhPhXNj62D8c33vuR5x1Zn6ZR2PmeMYvvFXEawUa1PkQtXTVmcX2U6sXpXcKq1Bk64qpZbhjD+vpCrL1laf8qUZgEr+sqK92/143BsBqhHN2hjatcT+cbGnbDiPbIlsTRpqwnJ9cqRdGjlmt09kS/tcTXMd24aNlEs9dLL19auoX/788kw9jnjbQ4zM+KxH/1D95bAP5lBNMct/Xsmf3595n5woP9HKkQo/dccy8jaN8bIldeqUWpVUb2mHL2trBrshADbl916r+nn5h4Nk7UileN+5FFYKVrvV11q+E6PhCB8lS1uGiPkRve04jE81LI/NcDjmw7I29qxItCXCYCYYKTr7V2eyaFudXYLkiQ53K+1VrRZrderaifSAn5dnjDM24bCX7aRlbspqUgeatI1Mtkvrn4/2qXSPbA1KSUp6R6FA61SxC5JZn9sXul5ZmfpNb2ukZfvLM12tesHb/nGQ+j8vWTnoz3ptJKoy36GbtIplS8pbARoNTYxPlNfaukwxWqfLfz8bMbalsEGSH9y1R3H5DrltSFl3Ppgw+PvJkRevipWbyKl2L1t//Ji5beRN9ItgYjssXSzZnJZJytZdr4dNW53dZOu9bYiXX+xbXWpVsvNep3bkuJfXqbRWcG9L29jubRfpny6yHfFU260K02OOky3rc9fFuoAO7o+cw3b1Dy+OvayjtqdlS6aSnCKV5OSxkV4sWzr1ZI+tbI/iOhqvqbfVaWvsyYWvTuNiav1EYOU7yFalszZrDfUovWrP2wKR7c46ZBvlbuuR7UO5bSlWI1uaM7bIdon9Q2Tbktu6dSGrUP3SlqTHrAVdZCtP6vdJ/Rst2yifHZ40c1vRKltWvtNMcuXmoTrLdu3e1iRSPqCNdhW4YUme9Lqg54EgOQzj8Ty5bRWmkU0UbCGyZefbZNsWJJthbG52xLxZHeSytP4huW3LTHJtzpPqTDzQPPY0g+Rj0ZCtvOP3Fzr/9fVz2bK2p3PbKhkki1bZVixIbsh2EuW2tE47m0UrNP6XQ2Tb8MaufHqRyJZX8fqOm0FWIiVzxffLNp3bPqJs7VSGjMIO3XiszrwVrf3HYa5Y5VnK9n7KhQ1ANiUl6zxqr7NLkHxNVDix08L1DZctPd8m2yGfkpq650NNhittI23X8vqHzCSfpddtzd6JWj9IKl3CfAA9pvcvyAIQ7fOGbIcX/zOy9fUz2fK2p2eSZc6oZ4jClJR0Uu8asp04tdHyTdlWJ74Ym5LSdbpcVVNp/TkHGepXV7gHw4TMFfPyH+gmLH+tn/56J3a+G3Vqkcp6TjvJNj2T/O3xZpLtnlYTH7kVi0PBh6WLosLyplssMC/iBSC6Cai1zk6yNXwyk05kLSjIlp6nsnXX6osndAHox5eB3bw3JusnrI2kXcvrH7f5SDZ8TIPqsEjkpoa1bM/C59Jjev+CyJb2eUO2aoVHNpLUz2TL2x42STGqsKBj13Z2tWNkslXbFV81ynPZGujCqhURKR8Wg6oTGv+S+u07Wp6fw3oRL0/KkGvJZ5mVWrfo4+p5+YBs0+u2d4PBl8eSrV20MyHLiGRWdFjawWXeYbto9UhobrcYPVxnl+0WdZ/obUKWaolsyflW2ZpVXJfgBm9VE82wNtJ2La1/wi4pWxN9FIRbOBoT+R+FWny8nfS2tM+bspWiNovorn4uW972lhUguoP4s0s9W70tLU9lay51hem66uddkpKGN4zyXKxL6jfvmGsnXrZReVKGXus/y+6wcLPJk06ybdsl9cWsAIl1M+u2uy5SdHU+XHZv5DZFtcwoLcrIjfLZvsfTbEs3wp5ksdG0uNvH47NRnct3V8nOPLTtSb57TG+b5tY8hI9nuuiBEcnqfHj0mp0USr2rka10QVq2ybmeVfTPVG8b3Pzv207D9sZ1oJNOkZ6HWjbzqLbtG0Aytz1Yt2xHPZa1duOBEcnq7ORt+34FaHVt7PVm/oaAmLN/Et+33Uju1utv/ULMkr9GnGAO1bZ831aK1jjbtcp2ru+BPjAiWZ1dRu91eivx0hjPo71EWzqDv27RiUlqK/FKmEO2LX/dws0j429J5Qn+ltQGsbMY+BNwW0MBciIP2c6C2EqKvHjypNhqINvtoMiMLdet+PlJN6zVrgJkwJMnAmQI7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCuWQPz5gnsmjUwb57ArlkD8+YJ7Jo1MG+ewK5ZA/PmCeyaNTBvnsCu+fLEmBcmzg/YNF+kbSHbPIFN88XIFhbOEBg1Y548gWzzQ9kTds2YJxoBssImPjBstkC2GWJkC7vmC6ybI9rVwrAZA+tmiJGtANkC6+YIcp8FKcB8CDA/UO2CFGA+BFgAyHYxCjAfAiwAVLsYGIDzkHWvFZkhMiTTZq0YyBayXbeNBJgVyBayXbeNBJiV3GUrsmFrZLtJ7VT3Et8Pfe2PU49Ve0L/urdR5s1QJFzRvMyVhWzRmI1olhv4RVEKHimJtaHuRf7wm4iOzT2WCnLbwjXE/LLHoaW0Yay4+wT70aVIVQrZojEb0Cw/8kUYmPKV+0esC6Mdf2uikbSoAuY+7RWlVrk6RRrSkK0WuT/XLGKu9tUmKoVs0Zj1N8sOYudmqI+i3jf45BnqT13QsS7n8kofnJYOq6kyDmaNwtwvd9/MvXrdl+6K8LgSjSmZRKVbIttUiiK6ZVE0QVngRkSUrCQzF/aajQSRf5DsJZqUbfC7s3lf46PKls8lXjJ9a0Fd/i5IxeEpExQYKP0lzl9TnbKXkUjNm/4R0ax0a2RbioTxOg0APwfAZh9mfOhHyUoq4Qmf1fgY99gWGeLdnpdIM7eN/e5sslUySH5u+VBVZelE58RLJFTGd6ntU4Z4tiQPIn7n3Nt6Tbv8mJQg90Er3UbZstDjwQp8kFOSysqZU64oWWlkM8m4qLRJVfayFW7UMm9LclsXkc4n25bPLboNAOHCYn3G3VXIdXnQ3AySS1FEYTAbQUHT1DH4J4ZvxlYGyUy2ocfKZPHwgmYyyWeltf79vVjEovTPAiLSyP42CCuFG11Zy9Z6v9YgmU/XEDuE7qUHgnd8KMxNQLJP5uBCNYWdRiYn+LApowTVjy6e25Zsrph7W1KOeF/hMoJUpdsgWzvu7WMvhC1Fwsp0cDBNmxlDd0i8rZPXA9EWS1aaCY8PxvgEhbd59rINje8qW+uJSdpbNOedSbxiCpcFdVzkKufRzGgpnc58yBM+Nb6Zkv4OBZhlS6b3Rm5bskcOnVAPAQatdDtkW5KEpAyzg86m1AbhBV+GYw9cnpmUXeI2/pBoJjxleJS6pCkMrW2RbSHactuUty3ZeyU5YNVHVtL6KolsaT3uP/e0LKLHCH3mx/Xz7McHv9RjMJ0yFYdnRmPMFYlKt0a2Lnny3ZLKkprqcw9w5xr1yZImO51kGycrbQkPy7+3SbZELG25Lbki6jAeLcfVN2Xr3gjCKiPZWvO689FTOuS2ZCD5ddto2tnfvffyDU9QkPkmHRGUwaeYD4or3R7Z8gdiCMlsuSinEaFHqYXTT8I4zPHveBcSJyuphIdkN4IusG+DbFlLi/QCkLD/MAfnHGzpV06iXrpPtj6kKUUsW3o5DZKLgk9klVRLrj2xJv1d2mCKSrIR0pVkNIi2SrdLtswUof9JdhPmi+mEQpBt80lIIyGWYpE8qpGspBIeEQ8Y/9HZy9Ypx4ev1FXxHhZNJRJ1+AOyvbeDbEVCtjQsCp9Kh0IwGpvZYOODxnb8Ce0+QdBUN+RsZoS0VbrVsi2bA8BvhxH0EVkyW/HnbcFnTUofBoU8Ku2iWcJTJCKnECFn723DaljoEO5yhfNEzOO4YKawlgsHdMrWHzlTCOfMUn3vAlk+F0QeJpFsyaNesEHhD4MHCKuyZSlEMz+mFTRMHn2syJY22RrjlCnZ8scxC3iDbEsWrrAgWfiHJ6kq6aJpwtMoEmLArZBt6G9RFNyxsjgndGY4KsMZeiBEojAv4pLGMsIXJiLmd8XMH57URVsSVbIEuCi4y2zI1gu8bKl0a2Tr/R+1ZVfZFix+LcikBXMIYSEhlGQ3w0I3lvCkizibb5Ns3aOKTQCJNWE+O5oaoicEy538I4Q/AlxtbLKZNrks+ftFyfdQNivdCtn6tJMLKSHbgj0TqeR9LOQfAUJEFwsmftEMe6L9kVHCExcJI3YrZCuCh0wfr4OHP3uOu2sIufF++VD92cu2cA+vdtkKkhPxR2EIUuke07KR3bDMqpFH2dpKFhY1Eh7RTHiYsrOXLehO/t7Wz85FbpLmqyw5EkY7hV2voWJ0DpBteGtkVo08Kk5W0glPESc8JJXKWrZgHkS2RI0ryQS7ebstwtH9EnatlWROpJnedLmNKFlpxEmhSPjcIt55A9mCgMiWhxrXrjoiySWkVh2SlZJvsxEkSgjbHUWGFGA+RLZk1bisLQWAp8gMAUD+FJkhAMifIjMEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgB/wc9D4sFYQyUCwAAAABJRU5ErkJggg==" width="950" height="248" class="img__I0M"></p>
<p>说明一下，定义泛型方法时，必须在返回值前边加一个<code>&lt;T&gt;</code>，来声明这是一个泛型方法，持有一个泛型<code>T</code>，然后才可以用泛型T作为方法的返回值。</p>
<p><code>Class&lt;T&gt;</code>的作用就是指明泛型的具体类型，而<code>Class&lt;T&gt;</code>类型的变量c，可以用来创建泛型类的对象。</p>
<p>为什么要用变量c来创建对象呢？既然是泛型方法，就代表着我们不知道具体的类型是什么，也不知道构造方法如何，因此没有办法去new一个对象，但可以利用变量c的newInstance方法去创建对象，也就是利用反射创建对象。</p>
<p>泛型方法要求的参数是<code>Class&lt;T&gt;</code>类型，而<code>Class.forName()</code>方法的返回值也是<code>Class&lt;T&gt;</code>，因此可以用<code>Class.forName()</code>作为参数。其中，<code>forName()</code>方法中的参数是何种类型，返回的<code>Class&lt;T&gt;</code>就是何种类型。在本例中，<code>forName()</code>方法中传入的是User类的完整路径，因此返回的是<code>Class&lt;User&gt;</code>类型的对象，因此调用泛型方法时，变量c的类型就是<code>Class&lt;User&gt;</code>，因此泛型方法中的泛型T就被指明为User，因此变量obj的类型为User。</p>
<p>当然，泛型方法不是仅仅可以有一个参数<code>Class&lt;T&gt;</code>，可以根据需要添加其他参数。</p>
<p><strong>为什么要使用泛型方法呢</strong>？因为泛型类要在实例化的时候就指明类型，如果想换一种类型，不得不重新new一次，可能不够灵活；而泛型方法可以在调用的时候指明类型，更加灵活。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型的上下限">泛型的上下限<a href="#泛型的上下限" class="hash-link" aria-label="泛型的上下限的直接链接" title="泛型的上下限的直接链接">​</a></h4>
<ul>
<li><strong>先看下如下的代码，很明显是会报错的</strong> （具体错误原因请参考后文）。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class A{}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class B extends A {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如下两个方法不会报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void funA(A a) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void funB(B b) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    funA(b);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如下funD方法会报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void funC(List&lt;A&gt; listA) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void funD(List&lt;B&gt; listB) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    funC(listB); // Unresolved compilation problem: The method doPrint(List&lt;A&gt;) in the type test is not applicable for the arguments (List&lt;B&gt;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>那么如何解决呢？</p>
<p>为了解决泛型中隐含的转换问题，Java泛型加入了类型参数的上下边界机制。<code>&lt;? extends A&gt;</code>表示该类型参数可以是A(上边界)或者A的子类类型。编译时擦除到类型A，即用A类型代替类型参数。这种方法可以解决开始遇到的问题，编译器知道类型参数的范围，如果传入的实例类型B是在这个范围内的话允许转换，这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void funC(List&lt;? extends A&gt; listA) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public static void funD(List&lt;B&gt; listB) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    funC(listB); // OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li><strong>泛型上下限的引入</strong></li>
</ul>
<p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p>上限</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Info&lt;T extends Number&gt;{    // 此处泛型只能是数字类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T var ;        // 定义泛型变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setVar(T var){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.var = var ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getVar(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.var ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString(){    // 直接打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.var.toString() ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class demo1{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Info&lt;Integer&gt; i1 = new Info&lt;Integer&gt;() ;        // 声明Integer的泛型对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>下限</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Info&lt;T&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T var ;        // 定义泛型变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setVar(T var){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.var = var ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getVar(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.var ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString(){    // 直接打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return this.var.toString() ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsDemo21{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Info&lt;String&gt; i1 = new Info&lt;String&gt;() ;        // 声明String的泛型对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Info&lt;Object&gt; i2 = new Info&lt;Object&gt;() ;        // 声明Object的泛型对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i1.setVar(&quot;hello&quot;) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i2.setVar(new Object()) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun(i1) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun(i2) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void fun(Info&lt;? super String&gt; temp){    // 只能接收String或Object类型的泛型，String类的父类只有Object类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(temp + &quot;, &quot;) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>小结</strong></p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;?&gt; 无限制通配符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;? extends E&gt; extends 关键字声明了类型的上界，表示参数化的类型可能是所指定的类型，或者是此类型的子类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;? super E&gt; super 关键字声明了类型的下界，表示参数化的类型可能是指定的类型，或者是此类型的父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 使用原则《Effictive Java》</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 为了获得最大限度的灵活性，要在表示 生产者或者消费者 的输入参数上使用通配符，使用的规则就是：生产者有上限、消费者有下限</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1. 如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2. 如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3. 如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</span><br></span></code></pre></div></div>
<ul>
<li>再看一个实际例子，<strong>加深印象</strong></li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private  &lt;E extends Comparable&lt;? super E&gt;&gt; E max(List&lt;? extends E&gt; e1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (e1 == null){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //迭代器返回的元素属于 E 的某个子类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Iterator&lt;? extends E&gt; iterator = e1.iterator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    E result = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (iterator.hasNext()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        E next = iterator.next();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (next.compareTo(result) &gt; 0){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            result = next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>上述代码中的类型参数 E 的范围是<code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code>，我们可以分步查看：</p>
<ul>
<li>要进行比较，所以 E 需要是可比较的类，因此需要 <code>extends Comparable&lt;…&gt;</code>（注意这里不要和继承的 <code>extends</code> 搞混了，不一样）</li>
<li><code>Comparable&lt; ? super E&gt;</code> 要对 E 进行比较，即 E 的消费者，所以需要用 super</li>
<li>而参数 <code>List&lt; ? extends E&gt;</code> 表示要操作的数据是 E 的子类的列表，指定上限，这样容器才够大</li>
<li><strong>多个限制</strong></li>
</ul>
<p>使用&amp;符号</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //工资低于2500元的上斑族并且站立的乘客车票打8折</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static &lt;T extends Staff &amp; Passenger&gt; void discount(T t){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(t.getSalary()&lt;2500 &amp;&amp; t.isStanding()){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;恭喜你！您的车票打八折！&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        discount(new Me());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型数组">泛型数组<a href="#泛型数组" class="hash-link" aria-label="泛型数组的直接链接" title="泛型数组的直接链接">​</a></h4>
<blockquote>
<p>具体可以参考下文中关于泛型数组的理解。</p>
</blockquote>
<p>首先，我们泛型数组相关的申明：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误，需要强转类型 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告</span><br></span></code></pre></div></div>
<p>那么通常我们如何用呢？</p>
<ul>
<li>讨巧的使用场景</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericsDemo30{  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String args[]){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer i[] = fun1(1,2,3,4,5,6) ;   // 返回泛型数组  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fun2(i) ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static &lt;T&gt; T[] fun1(T...arg){  // 接收可变参数  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return arg ;            // 返回泛型数组  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static &lt;T&gt; void fun2(T param[]){   // 输出  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.print(&quot;接收泛型数组：&quot;) ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for(T t:param){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print(t + &quot;、&quot;) ;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>合理使用</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public ArrayWithTypeToken(Class&lt;T&gt; type, int size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    array = (T[]) Array.newInstance(type, size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>具体可以查看后文解释。</p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="深入理解泛型">深入理解泛型<a href="#深入理解泛型" class="hash-link" aria-label="深入理解泛型的直接链接" title="深入理解泛型的直接链接">​</a></h3>
<p>提示</p>
<p>我们通过泛型背后的类型擦除以及相关的问题来进一步理解泛型。@pdai</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解java中的泛型是伪泛型泛型中类型擦除">如何理解Java中的泛型是伪泛型？泛型中类型擦除<a href="#如何理解java中的泛型是伪泛型泛型中类型擦除" class="hash-link" aria-label="如何理解Java中的泛型是伪泛型？泛型中类型擦除的直接链接" title="如何理解Java中的泛型是伪泛型？泛型中类型擦除的直接链接">​</a></h4>
<blockquote>
<p>Java泛型这个特性是从JDK 1.5才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。</p>
</blockquote>
<p><strong>泛型的类型擦除原则</strong>是：</p>
<ul>
<li>消除类型参数声明，即删除<code>&lt;&gt;</code>及其包围的部分。</li>
<li>根据类型参数的上下界推断并替换所有的类型参数为原生态类型：如果类型参数是无限制通配符或没有上下界限定则替换为Object，如果存在上下界限定则根据子类替换原则取类型参数的最左边限定类型（即父类）。</li>
<li>为了保证类型安全，必要时插入强制类型转换代码。</li>
<li>自动产生“桥接方法”以保证擦除类型后的代码仍然具有泛型的“多态性”。</li>
</ul>
<p><strong>那么如何进行擦除的呢</strong>？</p>
<p>参考自：<a href="http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/" target="_blank" rel="noopener noreferrer">http://softlab.sdut.edu.cn/blog/subaochen/2017/01/generics-type-erasure/</a></p>
<ul>
<li>擦除类定义中的类型参数 - 无限制类型擦除</li>
</ul>
<p>当类定义中的类型参数没有任何限制时，在类型擦除中直接被替换为Object，即形如<code>&lt;T&gt;</code>和<code>&lt;?&gt;</code>的类型参数都被替换为Object。</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-generic-1-b665cce02d0c0f476e095d4a4a8c2767.png" width="776" height="223" class="img__I0M"></p>
<ul>
<li>擦除类定义中的类型参数 - 有限制类型擦除</li>
</ul>
<p>当类定义中的类型参数存在限制（上下界）时，在类型擦除中替换为类型参数的上界或者下界，比如形如<code>&lt;T extends Number&gt;</code>和<code>&lt;? extends Number&gt;</code>的类型参数被替换为<code>Number</code>，<code>&lt;? super Number&gt;</code>被替换为Object。</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-generic-2-f7375674549e1f42d7e72cd0f998b697.png" width="822" height="236" class="img__I0M"></p>
<ul>
<li>擦除方法定义中的类型参数</li>
</ul>
<p>擦除方法定义中的类型参数原则和擦除类定义中的类型参数是一样的，这里仅以擦除方法定义中的有限制类型参数为例。</p>
<p><img decoding="async" loading="lazy" alt="img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA9YAAACQCAMAAADa3gNsAAAAclBMVEVHcEwAAAAAAAAAAQD/25QAAAAAAAAAAAAAAACY15oAAAABAQEAAAABAABgwGP/25f/ymeeZgHLhQv5yG3yz3b/25j014r/5bb/pQAAAAAInQ52TQEESwdDLAACKQS7eQAFcgkTEADnlgJKt04HjQwGfgt+M1WoAAAAGHRSTlMAiES7dRjVbe51M5lVqsLR+v7+qSymVHcgh9A8AAAYuElEQVR4nO2dC3ujLNPHBRdxPdxpsoe3bM55u9//Kz4zAygazaFJt2Lnf13btYmKRX7OMMCYJKyvKdlKi5ulm4NUwmKxPkUFEmiJTK0y82RleNaWecadxXqqgKoK+Spv5DdLu6pHrXQd7nbbiS3nRcJise6Tc6EvURzy+mQHWgVO/IVHCXxREuNsyVmsEZFJrocZSi1CQlTIW/IpUs7xLwcuMUcrrj/rylisaYlYBlDyAX+3tnZ4orawdSh6113jVScs1leTQiLOWM6o41pF2HEt8OHUM+KAt2b3nDV/Kdv68577WhLLyRyk0ISXoQFnulkzVSGx05z1+6JzYXlI6I/UXboZbtY8BNa57OBsI0tfZ3SoS3eeiopHxlixShHPedBrLr90nBjpbqojhapIWKyI1PM9s5R7lo2UFLV3XbJas91mTV9F1TZajhSNCw2388kZbdZ01QE6Y55vEFRZxmizpinVA5oDQndItWgL7myzJiFolE0QiIF+r6C7bT3yvKwSFusThaGfvA2JMdAPyqHNZLM+SUEwN+MJFs+T0jWTzfoMKV1m7bQKJvrZqsqcyWb9SzVIM9EfKUe24BpmfbQapDMm+uNlyS45YMH6OBWM9L+XxipPecyL9SGyhoOR/veSGBrPdMJiPVUuNMtIf5KKkiqf6571NClyAyEoq7lZfZoU+koZu+Ksp6iwUxrBTCesT5USADYbbNbDkrY7nQmOxE5BCvrYGd8K1iNyvnfNrvd0pNFgJyzWOyVLZnqCYoPNercUdag58jpFocHmOAfrblU0mMWTkScqlZmc7TXrPlGPOmPne7pCrvn2sO5QhVCXPDw6aancZMw161bRLMWSW8zUVeQmTVisW8RQR6MKblTCYl2VwkBZzVDHIc3hcNYN0rz6LyqVbK5Z14SmmqGOSZXJExbrkoqM5yTGppy9cNZF6dzk3EYiE3vhrIsqeZpxhGIvnHVJGY9qRSn2wlnjEsZwlqzYVOgiSfm+scYkmeoIJUydGMNDF6xhqYynIUao1AhlDHedWMOqeTFQjMqNBDcrYbGGxHMQoxRaas1uFmtEOc9CiVGVyaB7zePWrEFx/yxOYcQs5Scya1jcP4tTgLTkQDhrRNw/i1MQMUv9rVNMN6sr7p9FKeg7add9UiUPZbB64v5ZlIKImY11KnrjHs/nZ3WU8QyzGCUM5R6VNb8flzUgaB8JKzphzjlNmec49QXrXDzAFaXwlbgMNWtUme1c//y1WCy+/UxYMUgZEmdzZ41Igxf+c/Hy8gp6eVn8SljTV2U48TPrkuDBvySmnRbvstg/fyxQPxLWv5BgqFmXJdan11Avv+8+xe+FezCAuWc//h+o5jeZPl2/v81GyODitaeX/7uzQn6E1v6FLTYrRv14nY2+DVB9t73uneFlkbCepO//PUvfE9ZlzQrr3y8DH98F5uKxw1kX9P3Ps/TfHaX+/v4sxdQjmxXWQ1Tf5UgPWPtXDqc/SZ+D9X9PKzUmH2FOWH8b/vx2ezto7V84bvYcMdb/TnPCejHyxc32dvHgY4F1SYz1O6WboQItQDL4YuyQD8d63xty+rhDf72MfHErl99e18uBwy8F3aieL4/P6JHFCwqOTSJW26Z6lTDW2G7D+rB5ey7Wh82Tyr2CNVbClRsqxhLtyerSCpe0yTAh0jQLVimmo1lDOlivjdf6Fo6W29X1ndZmP/LN1hzxP7O9/9Bheu2zoPkbmvO+2CqwujBFcbE3S7our/3VxwLV8+VZj9Xw9yo3WdRJH9o2lXbrdayxEdabHVG2G2VtYw43Y61Tq0tM/HfcteX+faTcK1hTi7m8Szm8llxl5mL+jzRsQSLAWowe9aPL6XZ7NEf4ubyFo5uwu4Q1ffVkrFdw9XBm+NE8mqh3nAJFqAureV+2dClrqgU8zeoq1lTPVyYzD9MrY0/50KE3rISxxkZY74xBq2h2z8BamPwq1qk9ny338Ei5153w9ArWajgfgL6SJmAU63H9OGdpeytHj2O9fibWrQ8OFrvzxbd+3Qzq26p1UrZh0ZeDZlex1oM7yNhTPoxiPSaP9eaJWF/3d3Jbki33k7FO6sHXB7aVp1Ncn5pVtIkGSODP1Gi054Xb2bWbAh9o7jgl8u4CuBbr1Xo1ivX6CPYPvj5tt9jdXaIl9CYNvz+h+0494fV2f/Q+/BK3LJt4gv6JwQk3J4v1ityDJf7cwq5w0HGFl7IE9I97W4K7BNoZznxcv667fe/FGNYUMwuwpiQcNdUSvt/ez0j+tTWnYazxsSCtTaD/7IL/qndTUkGVTbVeZW1GAGXqgXsZEdbQ2KCzQbXkGxtVqCrT1PWpm0rQQWNLdN3skLRYo9lEvKxHTN7xbrPbbeDfG+GFv9iOLmy5Tdj5L/xyGMVa1u4SofKDYrXZOKx3R4e1L/cvbsEpx8r948o9uHK/t/VBbadKoQUUUDNNYR7rgtpK4VpMe2FwNUOORYs1uB+5KKlHYz+kVoukC/9iiwZrJUTmHyMZ7CBCr9BhfVo7l3gQ663ZImnQ6JcE4RE313DIGoRHI4lbOhBYXQOBRCltHvG0tLk1/bOukX88bE8PAvvrEQ7f0lVAkXCYMfQ8gc+2dAmwM/2yJXMf0ncr1lgJKdUSvtsHNm3yhcVx+zqINR2v7F6lgVsq8lrA81F2bwq1MUk/tclxB3cPs6FndERYQ2MzKSUwaRob/chy+DTrVgJgnfvGBu0zDV6e5LDeIGiI14GIs7+aHdzrHW5u4GG/c646bO+O1sDCzvCLM7YDWFfGXyK+A8Jv4jX8/dOWewjLPcCWwceMKxc2oLA32jkod+fL/d6WRbcuxcX92LeDSrCFeaztvbU/oSm0VzP8hO9grfDAuod1phqexUDITNNpVfDIIKz3wM7Rmb4BrIll+OnQA8RWblfX9tcu1LQkVoF7OuCIu+3paWHt4KmP9X57PMd6TafDb4InybrdAU+Jxa3QvLfXfQnrRdL0rQXelZSqR/v6qC1/P4JA4TnW0EDw1uTYjAuVuMpPBrFWdB9UnvnmXQzdy2jS+0BjK1x76mKtmroTAyEzTTsUTSt0WB8whtXHekf/o0EFvP66T+HHGwFJeOF/b5se1pmPP+dYxxrjFSrHqy1d6CIzfxzWWMgZ1htb7q5fLhS1I688KLd1wunGWkS1ohusO395gLVtCtoHUgaf8CHWwl50D2udNHZlCOv0LHvID+sgtyM7A1g759QGrsFS+ubfYG0PITbtvi2qFpDtUGgdvlkCoOdY7+GQtfEUw+MB/lHZJypoH1wh+ea293DBCbd9a4+1oBf6KOSvJuBc9Go1ijXFzOgZXQWV6kzFANbO16pNkfTbvJdKTTSp+GxCV3pKdbAmT9PWwhDW/b/QY41A9bHeEGYb435H+437oun8S6byYI5DfWvj4s/uFiIP9hY5CBKTNVhvzNsg1gf80pX7hsUcjfMPuuW2WJf2GdI8l73nNYC1bWxJnnfrpqOsoVK0fkAHa6pc6wUNYZ2dnRWwhj5rYEcHscY+9PZIrIDDvX3tYn2i4PmWvHDraQdY007A2XG7PrfWr+D3XsUaTxmU4E/cMHx0v4+HzH4noRPumhu2R1cvtmmuLltrekZbk02dczOOtbCPkKzvpod3MqKImXMsUtPDmv4qb0POse4P93is34CXc6wPXayRNPCKUQ7r3aWQmQ55qIKrCLCGci9ifRgud3OOdYGlWRiVgNtsnDEewDo1FKvPR+1qEY5ENzUtB7DORrHOh7BeHwNPdhjrtRX+sjrHeoVdb9RyDGvbd9+ezrBem9MlrJct1k0JXaz3eN79ZWv9kiRdrJVvjx2s/7uCNT6jrV8NN0JKeQnrkpzDfjwpIEX4/lgEctd/hrV9Oppgl05j6+eL9Fij2byEdR+v3aaL1xDWZzwMYI1l34N1v9wgEp5lzgeH4AyEWUp3HeNY+zDiubXuYS36NU1YV2196ludcNtH3S5P41i32ycX6AqxDseozrBuADltzfIM65NZ32StrRPuofX4reiJ5OfEtLPMelgv/B23KmlLWWuN9VHYXvJo35oi4eTdVc7xLP0JkhGsO9OJRvrW0bzb87K1HnXC8xFrDW715jZrHRjoK1hXobWmq3WOaX5ssT50yx1ywi+V+z2skcL64JUDeAhrbbHuEHfVCbe99sz5+Cq3WJdUVNmeu3u287HsJhJ+NGZsgGsdtHfc9m1+7Tn1MbQO1ifqi5+auVrt7iE6WzL+KxdF72O9fXUd6nAIu8E6eBihvo1h/StJQqx1W+m2PlxD+BY8OwbHrfOsNqqpWdFg7fik/hN9WnTHUwfjJDqmSHjtGxv9sSq3WIu2sYUjN76x1b2gYIP1HxtmHsN65/u4OxfFvgFrW+MKb4F0D93MXcRbgzV0mttydyN9653v01/CGh7sGQW37c1vrbUPeKf0qTgb0hocaA9DZqaWFaW7L0xeycy4AS4htRt5gb+xkrgF/iL08qSk4KwppRRBlL0dt15uxwa4cPxqv1/jYDWFpU80wEUwLvd7wugIG+vjPsQaz7Rf2nGz7Xq5Xx7N6hzrpXFR8zWG4/tY2zMsaUxt7UoIsO721tulHl2sLZUt1lAJVEu2PrQUfvhhPTJuvWgrPbN3Lcej3C2SJpOyoBZU4mlT2kwrWZWpu8lD88miGuCCdqZS20ozhZEFqtBcJtLFD4qgT9HarBzafNX88S3WG8LrD8aeN+YMa/jlbecmjxxwsvbf61jTmx8UgWQ3vWer3SwTwtqW++bK7WN9Vu5hFGt4UtubWuHfrX1TaB7VGJevKHwCFCKjwsJdDd70TiQ8Ny7sQm84yZy1xlCOez5UuZ2kaoLZ0EVmmg4+6aZZZiucTALoeqCXbh+aQ06PBLvDqoP1CSdXHwmQtTv+HOvXoxs9o13PnPCjn5++b0roh8xarH++DGK9cI2tcROpEnKqJY11lDtz+2NklpnHuvBVq6mWfZvSLnpW4Lnsg9vF1MreXQsVFdZZEyHMbGOjCk2DtiTsDjJsbDoILCYh1n8s1jhUbAeNu9aaPv7jdzDmcAPWVPn22WI3/Zv6jrsW67dOuX2sqdzNeLnfO1XifDSqmdqVhpO7nSdHTUE0V+NudjmYxz7EWipZuX1kJZMCjTH8UJVsj1TeWpPs50Ulw57eGdan/dD6jdVySZGvvbVn+32zt9vaL+1xK/rdnWO13J/sISf4vr8ca+W+WXV2hX8n+kelnZaNl+1LaC7iDOvmj2muqjXWtoK8pPa/qXYz+bY9njrX5k7QrOCSzVEV1H1bj4XdxDui3KfteVU+Mic8IqzBw3P2RmmhVUEWQuLSrfZZSS6L6jQ2XKTW+qCE9d8DDVodyL3ebDZvb/gB/Hujf3/w/wN8bkl62+AutHV4O8daBU05KAs3m8BFaj3qv4c/5+X6f3+bcg8Xyg2xtmShsA7a6/B/eSVEodpKEK5RDK8D6GCdPEWzz2V2T3aT1aAf8OB6az2ygsvkIpKg2ZMa2yettzabP8/R4+utxfBLZ8Dvk+MzHN6leWE9kN7kHijLofXWj2ZHGVtvrdNr6/imorix3uwmg3U94qClZ3MgHtW8sD7n+h6qIcgx4N5zLrO4sX5aqR+ZHUU+ecrhzPKEJz87fvhdeb4xQs6ZR4cqRj5l5sz3/3+WOJfZ19OiMdgvi7tyhNPaBc4TPjMx1nPRr8Xi5eVlcR/UOByDvuYvfqvHrPTz5jzgZTqfPOFz1f33IHcjTs07uF75HVxfStLU/DKw2SnIsmffmPktYX0lQcQ0i2ax7D9Q2k6jifqv4PemRyBxJc/kA2cOJhxGrKcNm2pcmjYDrKNJVxKh0me1D2hsH/QAFmYW5umZsyGiz6PpVySxPkY35Ai9WeLjsAbHM5oONo47Su2mpVbaru+S0uCyLkr6UyTN4GQh7YRn/F35gzpnSvwRcM7m+wZrmi7sR9d9YVEopsQGE5fyzUI1t38Ua6X6B42oaL4fwVo92NYwE6MW8XSwhRGZW9hFjkZWtGmgsLbd+n+3EB3X3eQFLlvN2tVgvub8ysS6WSjjOPdY21V5fm29aSpJiqm7uEUee0L+SUiYqnR91KqzoMluh0k5McFKZuwybvCsKRFiIJemk/6TtOhO+CJ8CuegsTWFJd0lIPdceQpF6TyWDjY+gSqpKW1AKiWlYAitdRfrXEiZSlxih8uHe68XsXkEaPG4TLWUtUNhCGuNi45Fk3F28m+m0YZ7148LbngO3V+7NhtTWQvb2DK7uKmHNWVmti0U4jO9LEmZa2waUzgLd65kGGtK4dzu8J7GJkxtcrtsN4ruWJMnQOXkZ9ZhFqqkj7UzWZIquez5O3YdeJDuw+WWGcLaFuYy/kSANTYuDoY/KtfYFCYQwA2X0cff/h7WlHbFJ/vppyq1mUWosZGrrvpJycPGFhb2XqyhARSUFDaKDnaT6khibhQpXVrjEawLv69IBroxmKOvcOgXVfNigQGsYXQfC3OFKxlBjyXt+4Gsu9U0tsqnqw9Snp1hrcKD+o3N9vW8nVGY5CdJkkGsZaew9/X4qK/qsp7H0MFualqbtpMzirX7cARrNL4u0XZm2pcEDmIdFhaFVFR5fqep5rUGIkyUMoZ1c9BgY8ua/MAu3cwo1voJjQ2GQoR7pYPOI2gHfWvtMji8C2t8Blsf3I7zphewDguLQ+h/8Uyjh9S0GOA7bGzvwRq9cN/YBJwnvYC1eLixYRmeiaJOJq/2JXudZ1DewVrfhjV44c4tsjcqH8Ja2fSbMQaWMbkZG+wH1LSYbjo+j7VN3qxvwxq8cN/YqFfdWGvnELSN7RnzJlJMGJ0l0ahNI5zZnnPl/gz3aKMgR3oj1jgMYCNu9uVCHmvHcI0+k83e1ykshpAZiQ32Y2pajIvPJraR+bfVJC44dhPWmMzVJXXHo/R5j0+5xubic64w/a45bYETHoVarMHJqEXdRB4ym9UNRhZElt+IdeGy6tJREGNqXixQCps3Ohelzaor805hkWBtDXbJYL9TYb69TEtR2/tfYwDVBqvLqs5vxFr7xgZHYeJnuz8m6aUUgVBCJXLnbGaiKex9jS01MF4bkaem0yYwWNCbmf2wvn3VnI3ou/c3iyahOv2uz2fV1+5sGMXItN8f33Vs56DkMERpn5ZhYSIilxzro/MScNbtCtiknNfO/lGd+gS72Y1OOFhpxxnlgBZNBvLMRs8oausSO+ugsPc1NsA6i+dVK9NQZmKamSmxEWY8OeVRSSmHPnzfqYYaUJgmui0se9f8A8DaxPMa00lIxRY/K+ilCppniUco9d4On4wlF+xUpER0gCgIEUCggMGOTtV7O1A6pkA4651S1Dlkk/1llPFiny8hpe3bp5jsr6Bm7QRr9lLCvj2NyZ67Cl7B96VUENl5yYMfcxaMlkUztYL1HMmS3pjLNnu+moILriTPlvjHquwiokxwzc9RcgouuJxDjsToVNl+9lfraENjy+b+LJuKC17lPHT+CVK6dkb76/S0VZO6araS+VSi4Jyu/rMkndFOv44/ns7bhkwoHYpgrD9PYLRzb7W/gkM+a6xV3WTQ/Xwx1p8sKVKHdjn7vvacsZ5WqlHGegIqdG0dchj7mvPinzSqBXh3aWKJwQXPiZmGlC5dtsZ0th65mOtCZDW1LKMqNyWPcU1EqhKpRTufJdsSM50ksxMt5ikndbswOwnPdpuSpHAe+QzZLs381iIT1FNLlqF5FdkEpebJtp5OqPhZmiTUHDKbsLps65gypY+onFtjmyjUjPXUFbBtMoQ7iVgzi4RPFmrGOgopqcvUv0gmq0UV6SjYnMat7fzfqSag5Mmj0QgMtx8DI7hjeM1gV/PBuqI5/ZPNKqt4qUdkKqrWK7dueTSOrcrm0dgqu2xeTPWxygszY5XUIm3gNmkdAd1Fms9h1KWgjJOTTnKjonoRJauvAtxyN6OcwuWlqKbbpVIi+lWoyi2VrzlxFevDJcEvbyJqRPccRsMmJvVFs1+wPleq65hDvxuNNzfBJ6hBmtPQsT5HSHfdeuYUVpuybz51hUjzq7VYnyzod4u0dc0hrkbOOfN9h+AJyUizpiiJeAe+ufXOme/LCifuMtKsqUoh3vUg39xb7KjQounDpCUjzYpBQ3yDg15jB/yLW3AZTOPDhXNMNCs6Ad8ahr27fENzBhMuZHwTUx+qiU6UMSsFezCs6FWgAYf4Wo/wjGw4ID7bRt6PO+BcXDbRrNlJykqACQ8HyGbHuH+K5YGLEsPsWxbrYSkiHFr/OeLIOEGOlEfSH6cux5lHgmP6PCbA+qJqGc/MkJBzxFwj5xNxY8EoI8nQa+4M3wcRQjbPLJaXcryUo5R70i3rFvYPpV1RCfToIYzz4QsSPJ7HYt0mYkpYY36B8z7xKcXcO7L8D0r3di3tGbJr5ZT2tBwIY7EeVSE96o6/3Hy48uZJoWccvL+u/wGw2fapoYOiVwAAAABJRU5ErkJggg==" width="982" height="144" class="img__I0M"></p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何证明类型的擦除呢">如何证明类型的擦除呢？<a href="#如何证明类型的擦除呢" class="hash-link" aria-label="如何证明类型的擦除呢？的直接链接" title="如何证明类型的擦除呢？的直接链接">​</a></h4>
<blockquote>
<p>我们通过两个例子证明Java类型的类型擦除</p>
</blockquote>
<ul>
<li>原始类型相等</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list1.add(&quot;abc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list2.add(123);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(list1.getClass() == list2.getClass()); // true</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在这个例子中，我们定义了两个ArrayList数组，不过一个是<code>ArrayList&lt;String&gt;</code>泛型类型的，只能存储字符串；一个是<code>ArrayList&lt;Integer&gt;</code>泛型类型的，只能存储整数，最后，我们通过list1对象和list2对象的<code>getClass()</code>方法获取他们的类的信息，最后发现结果为true。说明泛型类型String和Integer都被擦除掉了，只剩下原始类型。</p>
<ul>
<li>通过反射添加其它类型元素</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.add(1);  //这样调用 add 方法只能存储整形，因为泛型类型的实例为 Integer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list.getClass().getMethod(&quot;add&quot;, Object.class).invoke(list, &quot;asd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; list.size(); i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(list.get(i));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在程序中定义了一个<code>ArrayList</code>泛型类型实例化为<code>Integer</code>对象，如果直接调用<code>add()</code>方法，那么只能存储整数数据，不过当我们利用反射调用<code>add()</code>方法的时候，却可以存储字符串，这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解类型擦除后保留的原始类型">如何理解类型擦除后保留的原始类型?<a href="#如何理解类型擦除后保留的原始类型" class="hash-link" aria-label="如何理解类型擦除后保留的原始类型?的直接链接" title="如何理解类型擦除后保留的原始类型?的直接链接">​</a></h4>
<blockquote>
<p>在上面，两次提到了原始类型，什么是原始类型？</p>
</blockquote>
<p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p>
<ul>
<li>原始类型Object</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Pair&lt;T&gt; {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(T  value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre></div></div>
<p>Pair的原始类型为:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Pair {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(Object  value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因为在<code>Pair&lt;T&gt;</code>中，<code>T</code> 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如<code>Pair&lt;String&gt;</code>或<code>Pair&lt;Integer&gt;</code>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。</p>
<p>从上面章节，我们也可以明白ArrayList被擦除类型后，原始类型也变为Object，所以通过反射我们就可以存储字符串了。</p>
<p>如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。</p>
<p>比如: Pair这样声明的话</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Pair&lt;T extends Comparable&gt; {}</span><br></span></code></pre></div></div>
<p>那么原始类型就是Comparable。</p>
<p>要区分原始类型和泛型变量的类型。</p>
<p>在调用泛型方法时，可以指定泛型，也可以不指定泛型:</p>
<ul>
<li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object</li>
<li>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**不指定泛型的时候*/  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int i = Test.add(1, 2); //这两个参数都是Integer，所以T为Integer类型  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Number f = Test.add(1, 1.2); //这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object o = Test.add(1, &quot;asd&quot;); //这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**指定泛型的时候*/  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int a = Test.&lt;Integer&gt;add(1, 2); //指定了Integer，所以只能为Integer类型或者其子类  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int b = Test.&lt;Integer&gt;add(1, 2.2); //编译错误，指定了Integer，不能为Float  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Number c = Test.&lt;Number&gt;add(1, 2.2); //指定为Number，所以可以为Integer和Float  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这是一个简单的泛型方法  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static &lt;T&gt; T add(T x,T y){  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return y;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象。</p>
<ul>
<li>Object泛型</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ArrayList list = new ArrayList();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(1);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(&quot;121&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(new Date());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解泛型的编译期检查">如何理解泛型的编译期检查？<a href="#如何理解泛型的编译期检查" class="hash-link" aria-label="如何理解泛型的编译期检查？的直接链接" title="如何理解泛型的编译期检查？的直接链接">​</a></h4>
<blockquote>
<p>既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList 创建的对象中添加整数会报错呢？不是说泛型变量String会在编译的时候变为Object类型吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p>
</blockquote>
<p>Java编译器是通过先检查代码中泛型的类型，然后在进行类型擦除，再进行编译。</p>
<p>例如：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static  void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(&quot;123&quot;);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list.add(123);//编译错误  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在上面的程序中，使用add方法添加一个整型，在IDE中，直接会报错，说明这就是在编译之前的检查，因为如果是在编译之后检查，类型擦除后，原始类型为Object，是应该允许任意引用类型添加的。可实际上却不是这样的，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p>
<p>那么，<strong>这个类型检查是针对谁的呢</strong>？我们先看看参数化类型和原始类型的兼容。</p>
<p>以 ArrayList举例子，以前的写法:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList list = new ArrayList();  </span><br></span></code></pre></div></div>
<p>现在的写法:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br></span></code></pre></div></div>
<p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;String&gt; list1 = new ArrayList(); //第一种 情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList list2 = new ArrayList&lt;String&gt;(); //第二种 情况</span><br></span></code></pre></div></div>
<p>这样是没有错误的，不过会有个编译时警告。</p>
<p>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则没有效果。</p>
<p>因为类型检查就是编译时完成的，new ArrayList()只是在内存中开辟了一个存储空间，可以存储任何类型对象，而真正涉及类型检查的是它的引用，因为我们是使用它引用list1来调用它的方法，比如说调用add方法，所以list1引用能完成泛型类型的检查。而引用list2没有使用泛型，所以不行。</p>
<p>举例子：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList&lt;String&gt; list1 = new ArrayList();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list1.add(&quot;1&quot;); //编译通过  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list1.add(1); //编译错误  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String str1 = list1.get(0); //返回类型就是String  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ArrayList list2 = new ArrayList&lt;String&gt;();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list2.add(&quot;1&quot;); //编译通过  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list2.add(1); //编译通过  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object object = list2.get(0); //返回类型就是Object  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new ArrayList&lt;String&gt;().add(&quot;11&quot;); //编译通过  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        new ArrayList&lt;String&gt;().add(22); //编译错误  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String str2 = new ArrayList&lt;String&gt;().get(0); //返回类型就是String  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre></div></div>
<p>通过上面的例子，我们可以明白，<strong>类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象</strong>。</p>
<p><strong>泛型中参数话类型为什么不考虑继承关系</strong>？</p>
<p>在Java中，像下面形式的引用传递是不允许的:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;String&gt; list1 = new ArrayList&lt;Object&gt;(); //编译错误  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;Object&gt; list2 = new ArrayList&lt;String&gt;(); //编译错误</span><br></span></code></pre></div></div>
<ul>
<li>我们先看第一种情况，将第一种情况拓展成下面的形式：</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;Object&gt; list1 = new ArrayList&lt;Object&gt;();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list1.add(new Object());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list1.add(new Object());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;String&gt; list2 = list1; //编译错误</span><br></span></code></pre></div></div>
<p>实际上，在第4行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用list2引用用get()方法取值的时候，返回的都是String类型的对象（上面提到了，类型检测是根据引用来决定的），可是它里面实际上已经被我们存放了Object类型的对象，这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p>
<ul>
<li>再看第二种情况，将第二种情况拓展成下面的形式：</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list1.add(new String());  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list1.add(new String());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ArrayList&lt;Object&gt; list2 = list1; //编译错误</span><br></span></code></pre></div></div>
<p>没错，这样的情况比第一种情况好的多，最起码，在我们用list2取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。</p>
<p>我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以java不允许这么干。再说，你如果又用list2往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是String类型的，还是Object类型的呢？</p>
<p>所以，要格外注意，泛型中的引用传递的问题。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解泛型的多态泛型的桥接方法">如何理解泛型的多态？泛型的桥接方法<a href="#如何理解泛型的多态泛型的桥接方法" class="hash-link" aria-label="如何理解泛型的多态？泛型的桥接方法的直接链接" title="如何理解泛型的多态？泛型的桥接方法的直接链接">​</a></h4>
<blockquote>
<p>类型擦除会造成多态的冲突，而JVM解决方法就是桥接方法。</p>
</blockquote>
<p>现在有这样一个泛型类：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Pair&lt;T&gt; {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(T value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>然后我们想要一个子类继承它。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class DateInter extends Pair&lt;Date&gt; {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(Date value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super.setValue(value);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Date getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return super.getValue();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>在这个子类中，我们设定父类的泛型类型为<code>Pair&lt;Date&gt;</code>，在子类中，我们覆盖了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public Date getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void setValue(Date value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.value = value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的<code>@Override</code>标签中也可以看到，一点问题也没有，实际上是这样的吗？</p>
<p>分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Pair {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Object value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(Object  value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre></div></div>
<p>再看子类的两个重写的方法的类型：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void setValue(Date value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    super.setValue(value);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Date getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return super.getValue();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果实在普通的继承关系中，根本就不会是重写，而是重载。 我们在一个main方法测试一下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) throws ClassNotFoundException {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DateInter dateInter = new DateInter();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dateInter.setValue(new Date());                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dateInter.setValue(new Object()); //编译错误  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，却是是重写了，而不是重载了。</p>
<p><strong>为什么会这样呢</strong>？</p>
<p>原因是这样的，我们传入父类的泛型类型是Date，<code>Pair&lt;Date&gt;</code>，我们的本意是将泛型类变为如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class Pair {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Date value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Date getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setValue(Date value) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.value = value;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>然后再子类中重写参数类型为Date的那两个方法，实现继承中的多态。</p>
<p>可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。</p>
<blockquote>
<p>于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。</p>
</blockquote>
<p>首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class com.tao.test.DateInter extends com.tao.test.Pair&lt;java.util.Date&gt; {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  com.tao.test.DateInter();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: aload_0  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1: invokespecial #8                  // Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       4: return  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setValue(java.util.Date);  //我们重写的setValue方法  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: aload_0  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1: aload_1  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       5: return  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public java.util.Date getValue();    //我们重写的getValue方法  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: aload_0  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       4: checkcast     #26                 // class java/util/Date  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       7: areturn  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public java.lang.Object getValue();     //编译时由编译器生成的桥方法  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: aload_0  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       4: areturn  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void setValue(java.lang.Object);   //编译时由编译器生成的桥方法  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: aload_0  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       1: aload_1  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       2: checkcast     #26                 // class java/util/Date  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       8: return  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。</p>
<p>所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p>
<p>不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。</p>
<p>setValue方法是为了解决类型擦除与多态之间的冲突。</p>
<p>而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系：</p>
<p>那么父类的getValue方法如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public Object getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return super.getValue();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>而子类重写的方法是：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public Date getValue() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return super.getValue();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p>
<p>并且，还有一点也许会有疑问，子类中的桥方法<code>Object getValue()</code>和<code>Date getValue()</code>是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分别这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解基本类型不能作为泛型类型">如何理解基本类型不能作为泛型类型？<a href="#如何理解基本类型不能作为泛型类型" class="hash-link" aria-label="如何理解基本类型不能作为泛型类型？的直接链接" title="如何理解基本类型不能作为泛型类型？的直接链接">​</a></h4>
<blockquote>
<p>比如，我们没有<code>ArrayList&lt;int&gt;</code>，只有<code>ArrayList&lt;Integer&gt;</code>, 为何？</p>
</blockquote>
<p>因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储int值，只能引用Integer的值。</p>
<p>另外需要注意，我们能够使用<code>list.add(1)</code>是因为Java基础类型的自动装箱拆箱操作。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解泛型类型不能实例化">如何理解泛型类型不能实例化？<a href="#如何理解泛型类型不能实例化" class="hash-link" aria-label="如何理解泛型类型不能实例化？的直接链接" title="如何理解泛型类型不能实例化？的直接链接">​</a></h4>
<blockquote>
<p>不能实例化泛型类型, 这本质上是由于类型擦除决定的：</p>
</blockquote>
<p>我们可以看到如下代码会在编译器中报错：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">T test = new T(); // ERROR</span><br></span></code></pre></div></div>
<p>因为在 Java 编译期没法确定泛型参数化类型，也就找不到对应的类字节码文件，所以自然就不行了，此外由于<code>T</code> 被擦除为 <code>Object</code>，如果可以 <code>new T()</code> 则就变成了 <code>new Object()</code>，失去了本意。   如果我们确实需要实例化一个泛型，应该如何做呢？可以通过反射实现：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">static &lt;T&gt; T newTclass (Class &lt; T &gt; clazz) throws InstantiationException, IllegalAccessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    T obj = clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return obj;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型数组能不能采用具体的泛型类型进行初始化">泛型数组：能不能采用具体的泛型类型进行初始化？<a href="#泛型数组能不能采用具体的泛型类型进行初始化" class="hash-link" aria-label="泛型数组：能不能采用具体的泛型类型进行初始化？的直接链接" title="泛型数组：能不能采用具体的泛型类型进行初始化？的直接链接">​</a></h4>
<p>我们先来看下Oracle官网提供的一个例子：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object o = lsa;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object[] oa = (Object[]) o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">li.add(new Integer(3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">oa[1] = li; // Unsound, but passes run time store check</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">String s = lsa[1].get(0); // Run-time error ClassCastException.</span><br></span></code></pre></div></div>
<p>由于 JVM 泛型的擦除机制，所以上面代码可以给 <code>oa[1]</code> 赋值为 ArrayList 也不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现 <code>ClassCastException</code>，如果可以进行泛型数组的声明则上面说的这种情况在编译期不会出现任何警告和错误，只有在运行时才会出错，但是泛型的出现就是为了消灭 <code>ClassCastException</code>，所以如果 Java 支持泛型数组初始化操作就是搬起石头砸自己的脚。</p>
<p>而对于下面的代码来说是成立的：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object o = lsa;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Object[] oa = (Object[]) o;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">li.add(new Integer(3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">oa[1] = li; // Correct.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer i = (Integer) lsa[1].get(0); // OK</span><br></span></code></pre></div></div>
<p>所以说采用通配符的方式初始化泛型数组是允许的，因为对于通配符的方式最后取出数据是要做显式类型转换的，符合预期逻辑。综述就是说Java 的泛型数组初始化时数组类型不能是具体的泛型类型，只能是通配符的形式，因为具体类型会导致可存入任意类型对象，在取出时会发生类型转换异常，会与泛型的设计思想冲突，而通配符形式本来就需要自己强转，符合预期。</p>
<p>Oracle 官方文档：<a href="https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html在新窗口打开</a></p>
<p>更进一步的，我们看看如下的代码：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list11 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list12 = new ArrayList&lt;?&gt;[10]; //编译错误，需要强转类型 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) new ArrayList&lt;?&gt;[10]; //OK，但是会有警告 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;?&gt;[] list14 = new ArrayList&lt;String&gt;[10]; //编译错误，非法创建 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;?&gt;[] list15 = new ArrayList&lt;?&gt;[10]; //OK </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List&lt;String&gt;[] list6 = new ArrayList[10]; //OK，但是会有警告</span><br></span></code></pre></div></div>
<p>因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="泛型数组如何正确的初始化泛型数组实例">泛型数组：如何正确的初始化泛型数组实例？<a href="#泛型数组如何正确的初始化泛型数组实例" class="hash-link" aria-label="泛型数组：如何正确的初始化泛型数组实例？的直接链接" title="泛型数组：如何正确的初始化泛型数组实例？的直接链接">​</a></h4>
<blockquote>
<p>这个无论我们通过<code>new ArrayList[10]</code> 的形式还是通过泛型通配符的形式初始化泛型数组实例都是存在警告的，也就是说仅仅语法合格，运行时潜在的风险需要我们自己来承担，因此那些方式初始化泛型数组都不是最优雅的方式。</p>
</blockquote>
<p>我们在使用到泛型数组的场景下应该尽量使用列表集合替换，此外也可以通过使用 <code>java.lang.reflect.Array.newInstance(Class&lt;T&gt; componentType, int length)</code> 方法来创建一个具有指定类型和维度的数组，如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class ArrayWithTypeToken&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T[] array;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ArrayWithTypeToken(Class&lt;T&gt; type, int size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        array = (T[]) Array.newInstance(type, size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void put(int index, T item) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        array[index] = item;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T get(int index) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return array[index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T[] create() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return array;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ArrayWithTypeToken&lt;Integer&gt; arrayToken = new ArrayWithTypeToken&lt;Integer&gt;(Integer.class, 100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer[] array = arrayToken.create();</span><br></span></code></pre></div></div>
<p>所以使用反射来初始化泛型数组算是优雅实现，因为泛型类型 <code>T</code>在运行时才能被确定下来，我们能创建泛型数组也必然是在 Java 运行时想办法，而运行时能起作用的技术最好的就是反射了。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解泛型类中的静态方法和静态变量">如何理解泛型类中的静态方法和静态变量？<a href="#如何理解泛型类中的静态方法和静态变量" class="hash-link" aria-label="如何理解泛型类中的静态方法和静态变量？的直接链接" title="如何理解泛型类中的静态方法和静态变量？的直接链接">​</a></h4>
<blockquote>
<p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p>
</blockquote>
<p>举例说明：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test2&lt;T&gt; {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static T one;   //编译错误    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static  T show(T one){ //编译错误    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p>
<p>但是要注意区分下面的一种情况：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Test2&lt;T&gt; {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static &lt;T &gt;T show(T one){ //这是正确的    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何理解异常中使用泛型">如何理解异常中使用泛型？<a href="#如何理解异常中使用泛型" class="hash-link" aria-label="如何理解异常中使用泛型？的直接链接" title="如何理解异常中使用泛型？的直接链接">​</a></h4>
<ul>
<li><strong>不能抛出也不能捕获泛型类的对象</strong>。事实上，泛型类扩展Throwable都不合法。例如：下面的定义将不会通过编译：</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class Problem&lt;T&gt; extends Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>为什么不能扩展Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉，那么，假设上面的编译可行，那么，在看下面的定义：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch(Problem&lt;Integer&gt; e1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch(Problem&lt;Number&gt; e2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} </span><br></span></code></pre></div></div>
<p>类型信息被擦除后，那么两个地方的catch都变为原始类型Object，那么也就是说，这两个地方的catch变的一模一样,就相当于下面的这样</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch(Problem&lt;Object&gt; e1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch(Problem&lt;Object&gt; e2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这个当然就是不行的。</p>
<ul>
<li><strong>不能再catch子句中使用泛型变量</strong></li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch(T e) { //编译错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因为泛型信息在编译的时候已经变为原始类型，也就是说上面的T会变为原始类型Throwable，那么如果可以再catch子句中使用泛型变量，那么，下面的定义呢：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch(T e) { //编译错误</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch(IndexOutOfBounds e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }                         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>根据异常捕获的原则，一定是子类在前面，父类在后面，那么上面就违背了这个原则。即使你在使用该静态方法的使用T是<code>ArrayIndexOutofBounds</code>，在编译之后还是会变成Throwable，<code>ArrayIndexOutofBounds</code>是IndexOutofBounds的子类，违背了异常捕获的原则。所以java为了避免这样的情况，禁止在catch子句中使用泛型变量。</p>
<ul>
<li>但是在异常声明中可以使用类型变量。下面方法是合法的。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static&lt;T extends Throwable&gt; void doWork(T t) throws T {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch(Throwable realCause) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t.initCause(realCause);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw t; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>上面的这样使用是没问题的。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="如何获取泛型的参数类型">如何获取泛型的参数类型？<a href="#如何获取泛型的参数类型" class="hash-link" aria-label="如何获取泛型的参数类型？的直接链接" title="如何获取泛型的参数类型？的直接链接">​</a></h4>
<blockquote>
<p>既然类型被擦除了，那么如何获取泛型的参数类型呢？可以通过反射（<code>java.lang.reflect.Type</code>）获取泛型</p>
</blockquote>
<p><code>java.lang.reflect.Type</code>是Java中所有类型的公共高级接口, 代表了Java中的所有类型. Type体系中类型的包括：数组类型(GenericArrayType)、参数化类型(ParameterizedType)、类型变量(TypeVariable)、通配符类型(WildcardType)、原始类型(Class)、基本类型(Class), 以上这些类型都实现Type接口。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class GenericType&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private T data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T getData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setData(T data) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.data = data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        GenericType&lt;String&gt; genericType = new GenericType&lt;String&gt;() {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Type superclass = genericType.getClass().getGenericSuperclass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //getActualTypeArguments 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Type type = ((ParameterizedType) superclass).getActualTypeArguments()[0]; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(type);//class java.lang.String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>其中 <code>ParameterizedType</code>:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ParameterizedType extends Type {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 返回确切的泛型参数, 如Map&lt;String, Integer&gt;返回[String, Integer]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Type[] getActualTypeArguments();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //返回当前class或interface声明的类型, 如List&lt;?&gt;返回List</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Type getRawType();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //返回所属类型. 如,当前类型为O&lt;T&gt;.I&lt;S&gt;, 则返回O&lt;T&gt;. 顶级类型将返回null </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Type getOwnerType();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_Donx" id="注解机制详解">注解机制详解<a href="#注解机制详解" class="hash-link" aria-label="注解机制详解的直接链接" title="注解机制详解的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="注解基础">注解基础<a href="#注解基础" class="hash-link" aria-label="注解基础的直接链接" title="注解基础的直接链接">​</a></h3>
<p>注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<p>这么来说是比较抽象的，我们具体看下注解的常见分类：</p>
<ul>
<li><strong>Java自带的标准注解</strong>，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li><strong>元注解</strong>，元注解是用于定义注解的注解，包括<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>，<code>@Retention</code>用于标明注解被保留的阶段，<code>@Target</code>用于标明注解使用的范围，<code>@Inherited</code>用于标明注解可继承，<code>@Documented</code>用于标明是否生成javadoc文档。</li>
<li><strong>自定义注解</strong>，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。</li>
</ul>
<p>接下来我们通过这个分类角度来理解注解。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java内置注解">Java内置注解<a href="#java内置注解" class="hash-link" aria-label="Java内置注解的直接链接" title="Java内置注解的直接链接">​</a></h4>
<p>我们从最为常见的Java内置的注解开始说起，先看下下面的代码：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">class A{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class B extends A{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 重载父类的test方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 被弃用的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Deprecated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void oldMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * 忽略告警</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        * @return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;rawtypes&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List processList() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List list = new ArrayList();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Java 1.5开始自带的标准注解，包括<code>@Override</code>、<code>@Deprecated</code>和<code>@SuppressWarnings</code>：</p>
<ul>
<li><code>@Override</code>：表示当前的方法定义将覆盖父类中的方法</li>
<li><code>@Deprecated</code>：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告</li>
<li><code>@SuppressWarnings</code>：表示关闭编译器警告信息</li>
</ul>
<p>我们再具体看下这几个内置注解，同时通过这几个内置注解中的元注解的定义来引出元注解。</p>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="内置注解---override">内置注解 - @Override<a href="#内置注解---override" class="hash-link" aria-label="内置注解 - @Override的直接链接" title="内置注解 - @Override的直接链接">​</a></h5>
<p>我们先来看一下这个注解类型的定义：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.METHOD)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.SOURCE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Override {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。</p>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="内置注解---deprecated">内置注解 - @Deprecated<a href="#内置注解---deprecated" class="hash-link" aria-label="内置注解 - @Deprecated的直接链接" title="内置注解 - @Deprecated的直接链接">​</a></h5>
<p>这个注解的定义如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Deprecated {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。</p>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="内置注解---suppresswarnings">内置注解 - @SuppressWarnings<a href="#内置注解---suppresswarnings" class="hash-link" aria-label="内置注解 - @SuppressWarnings的直接链接" title="内置注解 - @SuppressWarnings的直接链接">​</a></h5>
<p>这个注解我们也比较常用到，先来看下它的定义：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.SOURCE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface SuppressWarnings {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String[] value();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息，它可以取的值如下所示：</p>
<table><thead><tr><th>参数</th><th>作用</th><th>原描述</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td><td>to suppress all warnings</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td><td>to suppress warnings relative to boxing/unboxing operations</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td><td>to suppress warnings relative to cast operations</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td><td>to suppress warnings relative to deprecated annotation</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td><td>to suppress warnings relative to deprecation</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td><td>to suppress warnings relative to missing breaks in switch statements</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td><td>to suppress warnings relative to finally block that don’t return</td></tr><tr><td>hiding</td><td>抑制与隐藏变数的区域变数相关的警告</td><td>to suppress warnings relative to locals that hide variable（）</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td><td>to suppress warnings relative to missing entries in a switch statement (enum case)</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td><td>to suppress warnings relative to non-nls string literals</td></tr><tr><td>null</td><td>忽略对null的操作</td><td>to suppress warnings relative to null analysis</td></tr><tr><td>rawtype</td><td>使用generics时忽略没有指定相应的类型</td><td>to suppress warnings relative to un-specific types when using</td></tr><tr><td>restriction</td><td>抑制与使用不建议或禁止参照相关的警告</td><td>to suppress warnings relative to usage of discouraged or</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td><td>to suppress warnings relative to missing serialVersionUID field for a serializable class</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td><td>to suppress warnings relative to incorrect static access</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td><td>to suppress warnings relative to unoptimized access from inner classes</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td><td>to suppress warnings relative to unchecked operations</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td><td>to suppress warnings relative to field access unqualified</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td><td>to suppress warnings relative to unused code</td></tr></tbody></table>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="元注解">元注解<a href="#元注解" class="hash-link" aria-label="元注解的直接链接" title="元注解的直接链接">​</a></h4>
<p>上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：<code>@Target</code>，<code>@Retention</code>，<code>@Documented</code>，<code>@Inherited</code>, 在JDK 1.8中提供了两个元注解 <code>@Repeatable</code>和<code>@Native</code>。</p>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="元注解---target">元注解 - @Target<a href="#元注解---target" class="hash-link" aria-label="元注解 - @Target的直接链接" title="元注解 - @Target的直接链接">​</a></h5>
<blockquote>
<p>Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。</p>
</blockquote>
<p>Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public enum ElementType {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TYPE, // 类、接口、枚举类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FIELD, // 成员变量（包括：枚举常量）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    METHOD, // 成员方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PARAMETER, // 方法参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CONSTRUCTOR, // 构造方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOCAL_VARIABLE, // 局部变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ANNOTATION_TYPE, // 注解类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PACKAGE, // 可用于修饰：包</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="元注解---retention--retentiontarget">元注解 - @Retention &amp; @RetentionTarget<a href="#元注解---retention--retentiontarget" class="hash-link" aria-label="元注解 - @Retention &amp; @RetentionTarget的直接链接" title="元注解 - @Retention &amp; @RetentionTarget的直接链接">​</a></h5>
<blockquote>
<p>Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。</p>
</blockquote>
<p>Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public enum RetentionPolicy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SOURCE,    // 源文件保留</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CLASS,       // 编译期保留，默认值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RUNTIME   // 运行期保留，可通过反射去获取注解信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.SOURCE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface SourcePolicy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.CLASS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface ClassPolicy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface RuntimePolicy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>用定义好的三个注解类分别去注解一个方法。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class RetentionTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@SourcePolicy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public void sourcePolicy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@ClassPolicy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public void classPolicy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@RuntimePolicy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public void runtimePolicy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>通过执行 <code>javap -verbose RetentionTest</code>命令获取到的RetentionTest 的 class 字节码内容如下。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public retention.RetentionTest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flags: ACC_PUBLIC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      stack=1, locals=1, args_size=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         0: aload_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         4: return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LineNumberTable:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        line 3: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void sourcePolicy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flags: ACC_PUBLIC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      stack=0, locals=1, args_size=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         0: return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LineNumberTable:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        line 7: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void classPolicy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flags: ACC_PUBLIC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      stack=0, locals=1, args_size=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         0: return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LineNumberTable:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        line 11: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RuntimeInvisibleAnnotations:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      0: #11()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void runtimePolicy();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    flags: ACC_PUBLIC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      stack=0, locals=1, args_size=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         0: return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      LineNumberTable:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        line 15: 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    RuntimeVisibleAnnotations:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      0: #14()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>从 RetentionTest 的字节码内容我们可以得出以下两点结论：</p>
<ul>
<li>编译器并没有记录下 sourcePolicy() 方法的注解信息；</li>
<li>编译器分别使用了 <code>RuntimeInvisibleAnnotations</code> 和 <code>RuntimeVisibleAnnotations</code> 属性去记录了<code>classPolicy()</code>方法 和 <code>runtimePolicy()</code>方法 的注解信息；</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="元注解---documented">元注解 - @Documented<a href="#元注解---documented" class="hash-link" aria-label="元注解 - @Documented的直接链接" title="元注解 - @Documented的直接链接">​</a></h5>
<blockquote>
<p>Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。</p>
</blockquote>
<p>以下代码在使用Javadoc工具可以生成<code>@TestDocAnnotation</code>注解信息。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.Documented;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.Target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target({ElementType.TYPE,ElementType.METHOD})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface TestDocAnnotation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	public String value() default &quot;default&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@TestDocAnnotation(&quot;myMethodDoc&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void testDoc() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="元注解---inherited">元注解 - @Inherited<a href="#元注解---inherited" class="hash-link" aria-label="元注解 - @Inherited的直接链接" title="元注解 - @Inherited的直接链接">​</a></h5>
<blockquote>
<p>Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
</blockquote>
<p>我们来测试下这个注解：</p>
<ul>
<li>定义<code>@Inherited</code>注解：</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Inherited</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target({ElementType.TYPE,ElementType.METHOD})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface TestInheritedAnnotation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String [] values();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int number();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>使用这个注解</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@TestInheritedAnnotation(values = {&quot;value&quot;}, number = 10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Person {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Student extends Person{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void test(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class clazz = Student.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Annotation[] annotations = clazz.getAnnotations();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Annotation annotation : annotations) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(annotation.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>输出</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">xxxxxxx.TestInheritedAnnotation(values=[value], number=10)</span><br></span></code></pre></div></div>
<p>即使Student类没有显示地被注解<code>@TestInheritedAnnotation</code>，但是它的父类Person被注解，而且<code>@TestInheritedAnnotation</code>被<code>@Inherited</code>注解，因此Student类自动有了该注解。</p>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="元注解---repeatable-java8">元注解 - @Repeatable (Java8)<a href="#元注解---repeatable-java8" class="hash-link" aria-label="元注解 - @Repeatable (Java8)的直接链接" title="元注解 - @Repeatable (Java8)的直接链接">​</a></h5>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="元注解---native-java8">元注解 - @Native (Java8)<a href="#元注解---native-java8" class="hash-link" aria-label="元注解 - @Native (Java8)的直接链接" title="元注解 - @Native (Java8)的直接链接">​</a></h5>
<p>使用 @Native 注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="注解与反射接口">注解与反射接口<a href="#注解与反射接口" class="hash-link" aria-label="注解与反射接口的直接链接" title="注解与反射接口的直接链接">​</a></h4>
<blockquote>
<p>定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：只有注解被定义为RUNTIME后，该注解才能是运行时可见，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。</p>
</blockquote>
<p>AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。我们看下具体的先关接口</p>
<ul>
<li><code>boolean isAnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)</code></li>
</ul>
<p>判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。</p>
<ul>
<li><code>Annotation[] getAnnotations()</code></li>
</ul>
<p>返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回该程序元素上存在的、指定类型的注解数组。没有注解对应类型的注解时，返回长度为0的数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。<code>getAnnotationsByType</code>方法与 <code>getAnnotation</code>的区别在于，<code>getAnnotationsByType</code>会检测注解对应的重复注解容器。若程序元素为类，当前类上找不到注解，且该注解为可继承的，则会去父类上检测对应的注解。</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释。如果没有注释直接存在于此元素上，则返回null</p>
<ul>
<li><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注释</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code></li>
</ul>
<p>返回直接存在于此元素上的所有注解及注解对应的重复注解容器。与此接口中的其他方法不同，该方法将忽略继承的注解。如果没有注释直接存在于此元素上，则返回长度为零的一个数组。该方法的调用者可以随意修改返回的数组，而不会对其他调用者返回的数组产生任何影响。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="自定义注解">自定义注解<a href="#自定义注解" class="hash-link" aria-label="自定义注解的直接链接" title="自定义注解的直接链接">​</a></h4>
<blockquote>
<p>当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：</p>
</blockquote>
<ul>
<li>定义自己的注解</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">package com.pdai.java.annotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.ElementType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.Retention;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.RetentionPolicy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.Target;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.METHOD)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface MyMethodAnnotation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String title() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String description() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>使用注解</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">package com.pdai.java.annotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.io.FileNotFoundException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.annotation.Annotation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.ArrayList;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.util.List;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TestMethodAnnotation {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @MyMethodAnnotation(title = &quot;toStringMethod&quot;, description = &quot;override toString method&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;Override toString method&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Deprecated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @MyMethodAnnotation(title = &quot;old static method&quot;, description = &quot;deprecated old static method&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void oldMethod() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;old method, don&#x27;t use it.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings({&quot;unchecked&quot;, &quot;deprecation&quot;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @MyMethodAnnotation(title = &quot;test method&quot;, description = &quot;suppress warning static method&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void genericsTest() throws FileNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        List l = new ArrayList();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        l.add(&quot;abc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        oldMethod();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>用反射接口获取注解信息</li>
</ul>
<p>在TestMethodAnnotation中添加Main方法进行测试：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取所有methods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method[] methods = TestMethodAnnotation.class.getClassLoader()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .loadClass((&quot;com.pdai.java.annotation.TestMethodAnnotation&quot;))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .getMethods();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Method method : methods) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 方法上是否有MyMethodAnnotation注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (method.isAnnotationPresent(MyMethodAnnotation.class)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 获取并遍历方法上的所有注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for (Annotation anno : method.getDeclaredAnnotations()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        System.out.println(&quot;Annotation in Method &#x27;&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                + method + &quot;&#x27; : &quot; + anno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 获取MyMethodAnnotation对象信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    MyMethodAnnotation methodAnno = method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .getAnnotation(MyMethodAnnotation.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.println(methodAnno.title());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ex.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (SecurityException | ClassNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>测试的输出</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Annotation in Method &#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27; : @java.lang.Deprecated()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Annotation in Method &#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.oldMethod()&#x27; : @com.pdai.java.annotation.MyMethodAnnotation(title=old static method, description=deprecated old static method)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">old static method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Annotation in Method &#x27;public static void com.pdai.java.annotation.TestMethodAnnotation.genericsTest() throws java.io.FileNotFoundException&#x27; : @com.pdai.java.annotation.MyMethodAnnotation(title=test method, description=suppress warning static method)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">test method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Annotation in Method &#x27;public java.lang.String com.pdai.java.annotation.TestMethodAnnotation.toString()&#x27; : @com.pdai.java.annotation.MyMethodAnnotation(title=toStringMethod, description=override toString method)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">toStringMethod</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="深入理解注解">深入理解注解<a href="#深入理解注解" class="hash-link" aria-label="深入理解注解的直接链接" title="深入理解注解的直接链接">​</a></h3>
<p>提示</p>
<p>接下来，我们从其它角度深入理解注解</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="java8提供了哪些新的注解">Java8提供了哪些新的注解？<a href="#java8提供了哪些新的注解" class="hash-link" aria-label="Java8提供了哪些新的注解？的直接链接" title="Java8提供了哪些新的注解？的直接链接">​</a></h4>
<ul>
<li>
<p><code>@Repeatable</code></p>
</li>
<li>
<p><code>ElementType.TYPE_USE</code></p>
</li>
<li>
<p><code>ElementType.TYPE_PARAMETER</code></p>
</li>
</ul>
<p><code>ElementType.TYPE_USE</code>(此类型包括类型声明和类型参数声明，是为了方便设计者进行类型检查)包含了<code>ElementType.TYPE</code>(类、接口（包括注解类型）和枚举的声明)和<code>ElementType.TYPE_PARAMETER</code>(类型参数声明), 不妨再看个例子</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">// 自定义ElementType.TYPE_PARAMETER注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.TYPE_PARAMETER)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface MyNotEmpty {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 自定义ElementType.TYPE_USE注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.TYPE_USE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface MyNotNull {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 测试类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class TypeParameterAndTypeUseAnnotation&lt;@MyNotEmpty T&gt;{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //使用TYPE_PARAMETER类型，会编译不通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//		public @MyNotEmpty T test(@MyNotEmpty T a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//			new ArrayList&lt;@MyNotEmpty String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//				return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//		}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //使用TYPE_USE类型，编译通过</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  public @MyNotNull T test2(@MyNotNull T a){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new ArrayList&lt;@MyNotNull String&gt;();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="注解支持继承吗">注解支持继承吗？<a href="#注解支持继承吗" class="hash-link" aria-label="注解支持继承吗？的直接链接" title="注解支持继承吗？的直接链接">​</a></h4>
<blockquote>
<p>注解是不支持继承的</p>
</blockquote>
<p>不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.</p>
<p>虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。</p>
<p>区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="注解实现的原理">注解实现的原理？<a href="#注解实现的原理" class="hash-link" aria-label="注解实现的原理？的直接链接" title="注解实现的原理？的直接链接">​</a></h4>
<blockquote>
<p>网上很多标注解的原理文章根本没有说到点子上。</p>
</blockquote>
<p>这里推荐你两篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_20009015/article/details/106038023</a></li>
<li><a href="https://www.race604.com/annotation-processing/" target="_blank" rel="noopener noreferrer">https://www.race604.com/annotation-processing/</a></li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="注解的应用场景">注解的应用场景<a href="#注解的应用场景" class="hash-link" aria-label="注解的应用场景的直接链接" title="注解的应用场景的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="配置化到注解化---框架的演进">配置化到注解化 - 框架的演进<a href="#配置化到注解化---框架的演进" class="hash-link" aria-label="配置化到注解化 - 框架的演进的直接链接" title="配置化到注解化 - 框架的演进的直接链接">​</a></h4>
<p>Spring 框架 配置化到注解化的转变。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="继承实现到注解实现---junit3到junit4">继承实现到注解实现 - Junit3到Junit4<a href="#继承实现到注解实现---junit3到junit4" class="hash-link" aria-label="继承实现到注解实现 - Junit3到Junit4的直接链接" title="继承实现到注解实现 - Junit3到Junit4的直接链接">​</a></h4>
<blockquote>
<p>一个模块的封装大多数人都是通过继承和组合等模式来实现的，但是如果结合注解将可以极大程度提高实现的优雅度（降低耦合度）。而Junit3 到Junit4的演化就是最好的一个例子。</p>
</blockquote>
<ul>
<li>被测试类</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorld {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void sayHello(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		System.out.println(&quot;hello....&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		throw new NumberFormatException();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void sayWorld(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		System.out.println(&quot;world....&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public String say(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		return &quot;hello world!&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>Junit 3 实现UT</li>
</ul>
<p>通过继承 TestCase来实现，初始化是通过Override父类方法来进行，测试方式通过test的前缀方法获取。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorldTest extends TestCase{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	private HelloWorld hw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	protected void setUp() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		super.setUp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw=new HelloWorld();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	//1.测试没有返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testHello(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 			hw.sayHello();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		} catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 			System.out.println(&quot;发生异常.....&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testWorld(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw.sayWorld();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	//2.测试有返回值的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	// 返回字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testSay(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		assertEquals(&quot;测试失败&quot;, hw.say(), &quot;hello world!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	//返回对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testObj(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		assertNull(&quot;测试对象不为空&quot;, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		assertNotNull(&quot;测试对象为空&quot;,new String());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	protected void tearDown() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		super.tearDown();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw=null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>Junit 4 实现UT</li>
</ul>
<p>通过定义@Before，@Test，@After等等注解来实现。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloWorldTest {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	private HelloWorld hw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Before</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void setUp() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw = new HelloWorld();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Test(expected=NumberFormatException.class)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	// 1.测试没有返回值,有别于junit3的使用，更加方便</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testHello() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw.sayHello();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testWorld() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw.sayWorld();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	// 2.测试有返回值的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	// 返回字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testSay() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		assertEquals(&quot;测试失败&quot;, hw.say(), &quot;hello world!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	// 返回对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void testObj() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		assertNull(&quot;测试对象不为空&quot;, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		assertNotNull(&quot;测试对象为空&quot;, new String());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	@After</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	public void tearDown() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 		hw = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 	}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这里我们发现通过注解的方式，我们实现单元测试时将更为优雅。如果你还期望了解Junit4是如何实现运行的呢？可以看这篇文章：<a href="https://blog.csdn.net/weixin_34043301/article/details/91799261" target="_blank" rel="noopener noreferrer">JUnit4源码分析运行原理在新窗口打开</a>。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="自定义注解和aop---通过切面实现解耦">自定义注解和AOP - 通过切面实现解耦<a href="#自定义注解和aop---通过切面实现解耦" class="hash-link" aria-label="自定义注解和AOP - 通过切面实现解耦的直接链接" title="自定义注解和AOP - 通过切面实现解耦的直接链接">​</a></h4>
<blockquote>
<p>最为常见的就是使用Spring AOP切面实现<strong>统一的操作日志管理</strong>，我这里找了一个开源项目中的例子（只展示主要代码），给你展示下如何通过注解实现解耦的。</p>
</blockquote>
<ul>
<li>自定义Log注解</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Target({ ElementType.PARAMETER, ElementType.METHOD })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Log {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 模块 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String title() default &quot;&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 功能</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public BusinessType businessType() default BusinessType.OTHER;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 操作人类别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public OperatorType operatorType() default OperatorType.MANAGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 是否保存请求的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean isSaveRequestData() default true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>实现日志的切面, 对自定义注解Log作切点进行拦截</li>
</ul>
<p>即对注解了@Log的方法进行切点拦截，</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Aspect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class LogAspect {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger log = LoggerFactory.getLogger(LogAspect.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 配置织入点 - 自定义注解的包路径</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Pointcut(&quot;@annotation(com.xxx.aspectj.lang.annotation.Log)&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void logPointCut() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 处理完请求后执行</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param joinPoint 切点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @AfterReturning(pointcut = &quot;logPointCut()&quot;, returning = &quot;jsonResult&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doAfterReturning(JoinPoint joinPoint, Object jsonResult) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleLog(joinPoint, null, jsonResult);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 拦截异常操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param joinPoint 切点</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param e 异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @AfterThrowing(value = &quot;logPointCut()&quot;, throwing = &quot;e&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void doAfterThrowing(JoinPoint joinPoint, Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleLog(joinPoint, e, null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void handleLog(final JoinPoint joinPoint, final Exception e, Object jsonResult) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获得注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Log controllerLog = getAnnotationLog(joinPoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (controllerLog == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取当前的用户</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            User currentUser = ShiroUtils.getSysUser();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // *========数据库日志=========*//</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            OperLog operLog = new OperLog();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            operLog.setStatus(BusinessStatus.SUCCESS.ordinal());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 请求的地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String ip = ShiroUtils.getIp();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            operLog.setOperIp(ip);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 返回参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            operLog.setJsonResult(JSONObject.toJSONString(jsonResult));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            operLog.setOperUrl(ServletUtils.getRequest().getRequestURI());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (currentUser != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                operLog.setOperName(currentUser.getLoginName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (StringUtils.isNotNull(currentUser.getDept())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        &amp;&amp; StringUtils.isNotEmpty(currentUser.getDept().getDeptName())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    operLog.setDeptName(currentUser.getDept().getDeptName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (e != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                operLog.setStatus(BusinessStatus.FAIL.ordinal());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                operLog.setErrorMsg(StringUtils.substring(e.getMessage(), 0, 2000));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 设置方法名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String className = joinPoint.getTarget().getClass().getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            String methodName = joinPoint.getSignature().getName();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            operLog.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 设置请求方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            operLog.setRequestMethod(ServletUtils.getRequest().getMethod());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 处理设置注解上的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            getControllerMethodDescription(controllerLog, operLog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 保存数据库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception exp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 记录本地异常日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;==前置通知异常==&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;异常信息:{}&quot;, exp.getMessage());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            exp.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取注解中对方法的描述信息 用于Controller层注解</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param log 日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param operLog 操作日志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void getControllerMethodDescription(Log log, OperLog operLog) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置action动作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        operLog.setBusinessType(log.businessType().ordinal());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置标题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        operLog.setTitle(log.title());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置操作人类别</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        operLog.setOperatorType(log.operatorType().ordinal());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 是否需要保存request，参数和值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (log.isSaveRequestData()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取参数的信息，传入到数据库中。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setRequestValue(operLog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取请求的参数，放到log中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param operLog</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param request</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void setRequestValue(OperLog operLog) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, String[]&gt; map = ServletUtils.getRequest().getParameterMap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String params = JSONObject.toJSONString(map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        operLog.setOperParam(StringUtils.substring(params, 0, 2000));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 是否存在注解，如果存在就获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Log getAnnotationLog(JoinPoint joinPoint) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Signature signature = joinPoint.getSignature();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MethodSignature methodSignature = (MethodSignature) signature;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method method = methodSignature.getMethod();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (method != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return method.getAnnotation(Log.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>使用@Log注解</li>
</ul>
<p>以一个简单的CRUD操作为例, 这里展示部分代码：每对“部门”进行操作就会产生一条操作日志存入数据库。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">@Controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/system/dept&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DeptController extends BaseController {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String prefix = &quot;system/dept&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Autowired</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private IDeptService deptService;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 新增保存部门</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Log(title = &quot;部门管理&quot;, businessType = BusinessType.INSERT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @RequiresPermissions(&quot;system:dept:add&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;/add&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ResponseBody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AjaxResult addSave(@Validated Dept dept) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return error(&quot;新增部门&#x27;&quot; + dept.getDeptName() + &quot;&#x27;失败，部门名称已存在&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return toAjax(deptService.insertDept(dept));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 保存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Log(title = &quot;部门管理&quot;, businessType = BusinessType.UPDATE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @RequiresPermissions(&quot;system:dept:edit&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;/edit&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ResponseBody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AjaxResult editSave(@Validated Dept dept) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (UserConstants.DEPT_NAME_NOT_UNIQUE.equals(deptService.checkDeptNameUnique(dept))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return error(&quot;修改部门&#x27;&quot; + dept.getDeptName() + &quot;&#x27;失败，部门名称已存在&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if(dept.getParentId().equals(dept.getDeptId())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return error(&quot;修改部门&#x27;&quot; + dept.getDeptName() + &quot;&#x27;失败，上级部门不能是自己&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return toAjax(deptService.updateDept(dept));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 删除</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Log(title = &quot;部门管理&quot;, businessType = BusinessType.DELETE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @RequiresPermissions(&quot;system:dept:remove&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @GetMapping(&quot;/remove/{deptId}&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ResponseBody</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public AjaxResult remove(@PathVariable(&quot;deptId&quot;) Long deptId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (deptService.selectDeptCount(deptId) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return AjaxResult.warn(&quot;存在下级部门,不允许删除&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (deptService.checkDeptExistUser(deptId)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return AjaxResult.warn(&quot;部门存在用户,不允许删除&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return toAjax(deptService.deleteDeptById(deptId));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<blockquote>
<p>同样的，你也可以看到权限管理也是通过类似的注解（<code>@RequiresPermissions</code>）机制来实现的。所以我们可以看到，通过注解+AOP最终的目标是为了实现模块的解耦。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_Donx" id="异常机制详解">异常机制详解<a href="#异常机制详解" class="hash-link" aria-label="异常机制详解的直接链接" title="异常机制详解的直接链接">​</a></h2>
<p>Java异常是Java提供的一种识别及响应错误的一致性机制，java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。本文综合多篇文章后，总结了Java 异常的相关知识，希望可以提升你对Java中异常的认知效率。</p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="异常的层次结构">异常的层次结构<a href="#异常的层次结构" class="hash-link" aria-label="异常的层次结构的直接链接" title="异常的层次结构的直接链接">​</a></h3>
<p>异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。</p>
<p>Java异常类层次结构图：</p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-exception-1-100f18d81a32f445f8a38bb194111eed.png" width="1098" height="767" class="img__I0M"></p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="throwable">Throwable<a href="#throwable" class="hash-link" aria-label="Throwable的直接链接" title="Throwable的直接链接">​</a></h4>
<p>Throwable 是 Java 语言中所有错误与异常的超类。</p>
<p>Throwable 包含两个子类：Error（错误）和 Exception（异常），它们通常用于指示发生了异常情况。</p>
<p>Throwable 包含了其线程创建时线程执行堆栈的快照，它提供了 printStackTrace() 等接口用于获取堆栈跟踪数据等信息。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="error错误">Error（错误）<a href="#error错误" class="hash-link" aria-label="Error（错误）的直接链接" title="Error（错误）的直接链接">​</a></h4>
<p>Error 类及其子类：程序中无法处理的错误，表示运行应用程序中出现了严重的错误。</p>
<p>此类错误一般表示代码运行时 JVM 出现问题。通常有 Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如 OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。此类错误发生时，JVM 将终止线程。</p>
<p>这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="exception异常">Exception（异常）<a href="#exception异常" class="hash-link" aria-label="Exception（异常）的直接链接" title="Exception（异常）的直接链接">​</a></h4>
<p>程序本身可以捕获并且可以处理的异常。Exception 这种异常又分为两类：运行时异常和编译时异常。</p>
<ul>
<li><strong>运行时异常</strong></li>
</ul>
<p>都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</p>
<ul>
<li><strong>非运行时异常</strong> （编译异常）</li>
</ul>
<p>是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="可查的异常checked-exceptions和不可查的异常unchecked-exceptions">可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）<a href="#可查的异常checked-exceptions和不可查的异常unchecked-exceptions" class="hash-link" aria-label="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）的直接链接" title="可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）的直接链接">​</a></h4>
<ul>
<li><strong>可查异常</strong>（编译器要求必须处置的异常）：</li>
</ul>
<p>正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。</p>
<p>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<ul>
<li><strong>不可查异常</strong>(编译器不要求强制处置的异常)</li>
</ul>
<p>包括运行时异常（RuntimeException与其子类）和错误（Error）。</p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="异常基础">异常基础<a href="#异常基础" class="hash-link" aria-label="异常基础的直接链接" title="异常基础的直接链接">​</a></h3>
<p>提示</p>
<p>接下来我们看下异常使用的基础。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常关键字">异常关键字<a href="#异常关键字" class="hash-link" aria-label="异常关键字的直接链接" title="异常关键字的直接链接">​</a></h4>
<ul>
<li><strong>try</strong> – 用于监听。将要被监听的代码(可能抛出异常的代码)放在try语句块之内，当try语句块内发生异常时，异常就被抛出。</li>
<li><strong>catch</strong> – 用于捕获异常。catch用来捕获try语句块中发生的异常。</li>
<li><strong>finally</strong> – finally语句块总是会被执行。它主要用于回收在try块里打开的物力资源(如数据库连接、网络连接和磁盘文件)。只有finally块，执行完成之后，才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了return或者throw等终止方法的语句，则就不会跳回执行，直接停止。</li>
<li><strong>throw</strong> – 用于抛出异常。</li>
<li><strong>throws</strong> – 用在方法签名中，用于声明该方法可能抛出的异常。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常的申明throws">异常的申明(throws)<a href="#异常的申明throws" class="hash-link" aria-label="异常的申明(throws)的直接链接" title="异常的申明(throws)的直接链接">​</a></h4>
<p>在Java中，当前执行的语句必属于某个方法，Java解释器调用main方法执行开始执行程序。若方法中存在检查异常，如果不对其捕获，那必须在方法头中显式声明该异常，以便于告知方法调用者此方法有异常，需要进行处理。 在方法中声明一个异常，方法头中使用关键字throws，后面接上要声明的异常。若声明多个异常，则使用逗号分割。如下所示：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void method() throws IOException, FileNotFoundException{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //something statements</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>注意：若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。</p>
<p>通常，应该捕获那些知道如何处理的异常，将不知道如何处理的异常继续传递下去。传递异常可以在方法签名处使用 throws 关键字声明可能会抛出的异常。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static void readFile(String filePath) throws IOException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    File file = new File(filePath);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BufferedReader reader = new BufferedReader(new FileReader(file));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while((result = reader.readLine())!=null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    reader.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Throws抛出异常的规则：</p>
<ul>
<li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li>
<li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li>
<li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li>
<li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常的抛出throw">异常的抛出(throw)<a href="#异常的抛出throw" class="hash-link" aria-label="异常的抛出(throw)的直接链接" title="异常的抛出(throw)的直接链接">​</a></h4>
<p>如果代码可能会引发某种错误，可以创建一个合适的异常类实例并抛出它，这就是抛出异常。如下所示：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static double method(int value) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if(value == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new ArithmeticException(&quot;参数不能为0&quot;); //抛出一个运行时异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 5.0 / value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>大部分情况下都不需要手动抛出异常，因为Java的大部分方法要么已经处理异常，要么已声明异常。所以一般都是捕获异常或者再往上抛。</p>
<p>有时我们会从 catch 中抛出一个异常，目的是为了改变异常的类型。多用于在多系统集成时，当某个子系统故障，异常类型可能有多种，可以用统一的异常类型向外暴露，不需暴露太多内部异常细节。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static void readFile(String filePath) throws MyException {    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyException ex = new MyException(&quot;read file failed.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ex.initCause(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw ex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常的自定义">异常的自定义<a href="#异常的自定义" class="hash-link" aria-label="异常的自定义的直接链接" title="异常的自定义的直接链接">​</a></h4>
<p>习惯上，定义一个异常类应包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数（Throwable 的 toString 方法会打印这些详细信息，调试时很有用）, 比如上面用到的自定义MyException：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class MyException extends Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyException(){ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MyException(String msg){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(msg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常的捕获">异常的捕获<a href="#异常的捕获" class="hash-link" aria-label="异常的捕获的直接链接" title="异常的捕获的直接链接">​</a></h4>
<p>异常捕获处理的方法通常有：</p>
<ul>
<li>try-catch</li>
<li>try-catch-finally</li>
<li>try-finally</li>
<li>try-with-resource</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="try-catch">try-catch<a href="#try-catch" class="hash-link" aria-label="try-catch的直接链接" title="try-catch的直接链接">​</a></h5>
<p>在一个 try-catch 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static void readFile(String filePath) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (FileNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // handle FileNotFoundException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // handle IOException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>同一个 catch 也可以捕获多种类型异常，用 | 隔开</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static void readFile(String filePath) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (FileNotFoundException | UnknownHostException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // handle FileNotFoundException or UnknownHostException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // handle IOException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="try-catch-finally">try-catch-finally<a href="#try-catch-finally" class="hash-link" aria-label="try-catch-finally的直接链接" title="try-catch-finally的直接链接">​</a></h5>
<ul>
<li>常规语法</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">try {                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //执行程序代码，可能会出现异常                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch(Exception e) {   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //捕获异常并处理   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //必执行的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>执行的顺序<!-- -->
<ul>
<li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li>
<li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li>
<li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li>
</ul>
</li>
</ul>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-exception-2-ea68cf3aed44a3f2e7f07166311c1efa.jpg" width="600" height="462" class="img__I0M"></p>
<ul>
<li>一个完整的例子</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static void readFile(String filePath) throws MyException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    File file = new File(filePath);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BufferedReader reader = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reader = new BufferedReader(new FileReader(file));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while((result = reader.readLine())!=null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;readFile method catch block.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MyException ex = new MyException(&quot;read file failed.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ex.initCause(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw ex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;readFile method finally block.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (null != reader) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                reader.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="try-finally">try-finally<a href="#try-finally" class="hash-link" aria-label="try-finally的直接链接" title="try-finally的直接链接">​</a></h5>
<blockquote>
<p>可以直接用try-finally吗？ 可以。</p>
</blockquote>
<p>try块中引起异常，异常代码之后的语句不再执行，直接执行finally语句。 try块没有引发异常，则执行完try块就执行finally语句。</p>
<p>try-finally可用在不需要捕获异常的代码，可以保证资源在使用后被关闭。例如IO流中执行完相应操作后，关闭相应资源；使用Lock对象保证线程同步，通过finally可以保证锁会被释放；数据库连接代码时，关闭连接操作等等。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">//以Lock加锁为例，演示try-finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ReentrantLock lock = new ReentrantLock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //需要加锁的代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lock.unlock(); //保证锁一定被释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>finally遇见如下情况不会执行</p>
<ul>
<li>在前面的代码中用了System.exit()退出程序。</li>
<li>finally语句块中发生了异常。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ul>
<h5 class="anchor anchorWithStickyNavbar_Donx" id="try-with-resource">try-with-resource<a href="#try-with-resource" class="hash-link" aria-label="try-with-resource的直接链接" title="try-with-resource的直接链接">​</a></h5>
<blockquote>
<p>try-with-resource是Java 7中引入的，很容易被忽略。</p>
</blockquote>
<p>上面例子中，finally 中的 close 方法也可能抛出 IOException, 从而覆盖了原始异常。JAVA 7 提供了更优雅的方式来实现资源的自动释放，自动释放的资源需要是实现了 AutoCloseable 接口的类。</p>
<ul>
<li>代码实现</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private  static void tryWithResourceTest(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try (Scanner scanner = new Scanner(new FileInputStream(&quot;c:/abc&quot;),&quot;UTF-8&quot;)){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // handle exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>看下Scanner</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public final class Scanner implements Iterator&lt;String&gt;, Closeable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface Closeable extends AutoCloseable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void close() throws IOException;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>try 代码块退出时，会自动调用 scanner.close 方法，和把 scanner.close 方法放在 finally 代码块中不同的是，若 scanner.close 抛出异常，则会被抑制，抛出的仍然为原始异常。被抑制的异常会由 addSusppressed 方法添加到原来的异常，如果想要获取被抑制的异常列表，可以调用 getSuppressed 方法来获取。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常基础总结">异常基础总结<a href="#异常基础总结" class="hash-link" aria-label="异常基础总结的直接链接" title="异常基础总结的直接链接">​</a></h4>
<ul>
<li>try、catch和finally都不能单独使用，只能是try-catch、try-finally或者try-catch-finally。</li>
<li>try语句块监控代码，出现异常就停止执行下面的代码，然后将异常移交给catch语句块来处理。</li>
<li>finally语句块中的代码一定会被执行，常用于回收资源 。</li>
<li>throws：声明一个异常，告知方法调用者。</li>
<li>throw ：抛出一个异常，至于该异常被捕获还是继续抛出都与它无关。</li>
</ul>
<p>Java编程思想一书中，对异常的总结。</p>
<ul>
<li>在恰当的级别处理问题。（在知道该如何处理的情况下了捕获异常。）</li>
<li>解决问题并且重新调用产生异常的方法。</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行。</li>
<li>用别的数据进行计算，以代替方法预计会返回的值。</li>
<li>把当前运行环境下能做的事尽量做完，然后把相同的异常重抛到更高层。</li>
<li>把当前运行环境下能做的事尽量做完，然后把不同的异常抛到更高层。</li>
<li>终止程序。</li>
<li>进行简化（如果你的异常模式使问题变得太复杂，那么用起来会非常痛苦）。</li>
<li>让类库和程序更安全。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="常用的异常">常用的异常<a href="#常用的异常" class="hash-link" aria-label="常用的异常的直接链接" title="常用的异常的直接链接">​</a></h4>
<p>在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类:</p>
<ul>
<li><strong>RuntimeException</strong>
<ul>
<li>java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>
<li>java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。</li>
<li>java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等</li>
<li>java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>
<li>java.lang.NegativeArraySizeException 数组长度为负异常</li>
<li>java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</li>
<li>java.lang.SecurityException 安全性异常</li>
<li>java.lang.IllegalArgumentException 非法参数异常</li>
</ul>
</li>
<li><strong>IOException</strong>
<ul>
<li>IOException：操作输入流和输出流时可能出现的异常。</li>
<li>EOFException 文件已结束异常</li>
<li>FileNotFoundException 文件未找到异常</li>
</ul>
</li>
<li><strong>其他</strong>
<ul>
<li>ClassCastException 类型转换异常类</li>
<li>ArrayStoreException 数组中包含不兼容的值抛出的异常</li>
<li>SQLException 操作数据库异常类</li>
<li>NoSuchFieldException 字段未找到异常</li>
<li>NoSuchMethodException 方法未找到抛出的异常</li>
<li>NumberFormatException 字符串转换为数字抛出的异常</li>
<li>StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常</li>
<li>IllegalAccessException 不允许访问某类异常</li>
<li>InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常</li>
</ul>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="异常实践">异常实践<a href="#异常实践" class="hash-link" aria-label="异常实践的直接链接" title="异常实践的直接链接">​</a></h3>
<p>提示</p>
<p>在 Java 中处理异常并不是一个简单的事情。不仅仅初学者很难理解，即使一些有经验的开发者也需要花费很多时间来思考如何处理异常，包括需要处理哪些异常，怎样处理等等。这也是绝大多数开发团队都会制定一些规则来规范进行异常处理的原因。</p>
<p>当你抛出或捕获异常的时候，有很多不同的情况需要考虑，而且大部分事情都是为了改善代码的可读性或者 API 的可用性。</p>
<p>异常不仅仅是一个错误控制机制，也是一个通信媒介。因此，为了和同事更好的合作，一个团队必须要制定出一个最佳实践和规则，只有这样，团队成员才能理解这些通用概念，同时在工作中使用它。</p>
<p>这里给出几个被很多团队使用的异常处理最佳实践。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="只针对不正常的情况才使用异常">只针对不正常的情况才使用异常<a href="#只针对不正常的情况才使用异常" class="hash-link" aria-label="只针对不正常的情况才使用异常的直接链接" title="只针对不正常的情况才使用异常的直接链接">​</a></h4>
<blockquote>
<p>异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。《阿里手册》中：【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。</p>
</blockquote>
<p>比如，在解析字符串形式的数字时，可能存在数字格式错误，不得通过catch Exception来实现</p>
<ul>
<li>代码1</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">if (obj != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>代码2</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">try { </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  obj.method(); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (NullPointerException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  //...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>主要原因有三点：</p>
<ul>
<li>异常机制的设计初衷是用于不正常的情况，所以很少会会JVM实现试图对它们的性能进行优化。所以，创建、抛出和捕获异常的开销是很昂贵的。</li>
<li>把代码放在try-catch中返回阻止了JVM实现本来可能要执行的某些特定的优化。</li>
<li>对数组进行遍历的标准模式并不会导致冗余的检查，有些现代的JVM实现会将它们优化掉。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="在-finally-块中清理资源或者使用-try-with-resource-语句">在 finally 块中清理资源或者使用 try-with-resource 语句<a href="#在-finally-块中清理资源或者使用-try-with-resource-语句" class="hash-link" aria-label="在 finally 块中清理资源或者使用 try-with-resource 语句的直接链接" title="在 finally 块中清理资源或者使用 try-with-resource 语句的直接链接">​</a></h4>
<p>当使用类似InputStream这种需要使用后关闭的资源时，一个常见的错误就是在try块的最后关闭资源。</p>
<ul>
<li>错误示例</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void doNotCloseResourceInTry() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileInputStream inputStream = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        File file = new File(&quot;./tmp.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputStream = new FileInputStream(file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // use the inputStream to read a file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do NOT do this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (FileNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>问题就是，只有没有异常抛出的时候，这段代码才可以正常工作。try 代码块内代码会正常执行，并且资源可以正常关闭。但是，使用 try 代码块是有原因的，一般调用一个或多个可能抛出异常的方法，而且，你自己也可能会抛出一个异常，这意味着代码可能不会执行到 try 代码块的最后部分。结果就是，你并没有关闭资源。</p>
<p>所以，你应该把清理工作的代码放到 finally 里去，或者使用 try-with-resource 特性。</p>
<ul>
<li>方法一：使用 finally 代码块</li>
</ul>
<p>与前面几行 try 代码块不同，finally 代码块总是会被执行。不管 try 代码块成功执行之后还是你在 catch 代码块中处理完异常后都会执行。因此，你可以确保你清理了所有打开的资源。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void closeResourceInFinally() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    FileInputStream inputStream = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        File file = new File(&quot;./tmp.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        inputStream = new FileInputStream(file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // use the inputStream to read a file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (FileNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (inputStream != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                inputStream.close();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<ul>
<li>方法二：Java 7 的 try-with-resource 语法</li>
</ul>
<p>如果你的资源实现了 AutoCloseable 接口，你可以使用这个语法。大多数的 Java 标准资源都继承了这个接口。当你在 try 子句中打开资源，资源会在 try 代码块执行后或异常处理后自动关闭。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void automaticallyCloseResource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    File file = new File(&quot;./tmp.txt&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try (FileInputStream inputStream = new FileInputStream(file);) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // use the inputStream to read a file</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (FileNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="尽量使用标准的异常">尽量使用标准的异常<a href="#尽量使用标准的异常" class="hash-link" aria-label="尽量使用标准的异常的直接链接" title="尽量使用标准的异常的直接链接">​</a></h4>
<blockquote>
<p>代码重用是值得提倡的，这是一条通用规则，异常也不例外。</p>
</blockquote>
<p>重用现有的异常有几个好处：</p>
<ul>
<li>它使得你的API更加易于学习和使用，因为它与程序员原来已经熟悉的习惯用法是一致的。</li>
<li>对于用到这些API的程序而言，它们的可读性更好，因为它们不会充斥着程序员不熟悉的异常。</li>
<li>异常类越少，意味着内存占用越小，并且转载这些类的时间开销也越小。</li>
</ul>
<p>Java标准异常中有几个是经常被使用的异常。如下表格：</p>
<table><thead><tr><th>异常</th><th>使用场合</th></tr></thead><tbody><tr><td>IllegalArgumentException</td><td>参数的值不合适</td></tr><tr><td>IllegalStateException</td><td>参数的状态不合适</td></tr><tr><td>NullPointerException</td><td>在null被禁止的情况下参数值为null</td></tr><tr><td>IndexOutOfBoundsException</td><td>下标越界</td></tr><tr><td>ConcurrentModificationException</td><td>在禁止并发修改的情况下，对象检测到并发修改</td></tr><tr><td>UnsupportedOperationException</td><td>对象不支持客户请求的方法</td></tr></tbody></table>
<p>虽然它们是Java平台库迄今为止最常被重用的异常，但是，在许可的条件下，其它的异常也可以被重用。例如，如果你要实现诸如复数或者矩阵之类的算术对象，那么重用ArithmeticException和NumberFormatException将是非常合适的。如果一个异常满足你的需要，则不要犹豫，使用就可以，不过你一定要确保抛出异常的条件与该异常的文档中描述的条件一致。这种重用必须建立在语义的基础上，而不是名字的基础上。</p>
<p>最后，一定要清楚，选择重用哪一种异常并没有必须遵循的规则。例如，考虑纸牌对象的情形，假设有一个用于发牌操作的方法，它的参数(handSize)是发一手牌的纸牌张数。假设调用者在这个参数中传递的值大于整副牌的剩余张数。那么这种情形既可以被解释为IllegalArgumentException(handSize的值太大)，也可以被解释为IllegalStateException(相对客户的请求而言，纸牌对象的纸牌太少)。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="对异常进行文档说明">对异常进行文档说明<a href="#对异常进行文档说明" class="hash-link" aria-label="对异常进行文档说明的直接链接" title="对异常进行文档说明的直接链接">​</a></h4>
<blockquote>
<p>当在方法上声明抛出异常时，也需要进行文档说明。目的是为了给调用者提供尽可能多的信息，从而可以更好地避免或处理异常。</p>
</blockquote>
<p>在 Javadoc 添加 @throws 声明，并且描述抛出异常的场景。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* Method description</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* @throws MyBusinessException - businuess exception description</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void doSomething(String input) throws MyBusinessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>同时，在抛出MyBusinessException 异常时，需要尽可能精确地描述问题和相关信息，这样无论是打印到日志中还是在监控工具中，都能够更容易被人阅读，从而可以更好地定位具体错误信息、错误的严重程度等。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="优先捕获最具体的异常">优先捕获最具体的异常<a href="#优先捕获最具体的异常" class="hash-link" aria-label="优先捕获最具体的异常的直接链接" title="优先捕获最具体的异常的直接链接">​</a></h4>
<blockquote>
<p>大多数 IDE 都可以帮助你实现这个最佳实践。当你尝试首先捕获较不具体的异常时，它们会报告无法访问的代码块。</p>
</blockquote>
<p>但问题在于，只有匹配异常的第一个 catch 块会被执行。 因此，如果首先捕获 IllegalArgumentException ，则永远不会到达应该处理更具体的 NumberFormatException 的 catch 块，因为它是 IllegalArgumentException 的子类。</p>
<p>总是优先捕获最具体的异常类，并将不太具体的 catch 块添加到列表的末尾。</p>
<p>你可以在下面的代码片断中看到这样一个 try-catch 语句的例子。 第一个 catch 块处理所有 NumberFormatException 异常，第二个处理所有非 NumberFormatException 异常的IllegalArgumentException 异常。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void catchMostSpecificExceptionFirst() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        doSomething(&quot;A message&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (NumberFormatException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IllegalArgumentException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(e)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="不要捕获-throwable-类">不要捕获 Throwable 类<a href="#不要捕获-throwable-类" class="hash-link" aria-label="不要捕获 Throwable 类的直接链接" title="不要捕获 Throwable 类的直接链接">​</a></h4>
<blockquote>
<p>Throwable 是所有异常和错误的超类。你可以在 catch 子句中使用它，但是你永远不应该这样做！</p>
</blockquote>
<p>如果在 catch 子句中使用 Throwable ，它不仅会捕获所有异常，也将捕获所有的错误。JVM 抛出错误，指出不应该由应用程序处理的严重问题。 典型的例子是 OutOfMemoryError 或者 StackOverflowError 。两者都是由应用程序控制之外的情况引起的，无法处理。</p>
<p>所以，最好不要捕获 Throwable ，除非你确定自己处于一种特殊的情况下能够处理错误。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void doNotCatchThrowable() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // don&#x27;t do this!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="不要忽略异常">不要忽略异常<a href="#不要忽略异常" class="hash-link" aria-label="不要忽略异常的直接链接" title="不要忽略异常的直接链接">​</a></h4>
<blockquote>
<p>很多时候，开发者很有自信不会抛出异常，因此写了一个catch块，但是没有做任何处理或者记录日志。</p>
</blockquote>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void doNotIgnoreExceptions() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (NumberFormatException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // this will never happen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>但现实是经常会出现无法预料的异常，或者无法确定这里的代码未来是不是会改动(删除了阻止异常抛出的代码)，而此时由于异常被捕获，使得无法拿到足够的错误信息来定位问题。</p>
<p>合理的做法是至少要记录异常的信息。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void logAnException() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (NumberFormatException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.error(&quot;This should never happen: &quot; + e); // see this line</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="不要记录并抛出异常">不要记录并抛出异常<a href="#不要记录并抛出异常" class="hash-link" aria-label="不要记录并抛出异常的直接链接" title="不要记录并抛出异常的直接链接">​</a></h4>
<blockquote>
<p>这可能是本文中最常被忽略的最佳实践。</p>
</blockquote>
<p>可以发现很多代码甚至类库中都会有捕获异常、记录日志并再次抛出的逻辑。如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    new Long(&quot;xyz&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} catch (NumberFormatException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.error(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    throw e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这个处理逻辑看着是合理的。但这经常会给同一个异常输出多条日志。如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">17:44:28,945 ERROR TestExceptionHandling:65 - java.lang.NumberFormatException: For input string: &quot;xyz&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;xyz&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">at java.lang.Long.parseLong(Long.java:589)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">at java.lang.Long.(Long.java:965)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">at com.stackify.example.TestExceptionHandling.logAndThrowException(TestExceptionHandling.java:63)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">at com.stackify.example.TestExceptionHandling.main(TestExceptionHandling.java:58)</span><br></span></code></pre></div></div>
<p>如上所示，后面的日志也没有附加更有用的信息。如果想要提供更加有用的信息，那么可以将异常包装为自定义异常。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void wrapException(String input) throws MyBusinessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (NumberFormatException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new MyBusinessException(&quot;A message that describes the error.&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>因此，仅仅当想要处理异常时才去捕获，否则只需要在方法签名中声明让调用者去处理。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="包装异常时不要抛弃原始的异常">包装异常时不要抛弃原始的异常<a href="#包装异常时不要抛弃原始的异常" class="hash-link" aria-label="包装异常时不要抛弃原始的异常的直接链接" title="包装异常时不要抛弃原始的异常的直接链接">​</a></h4>
<p>捕获标准异常并包装为自定义异常是一个很常见的做法。这样可以添加更为具体的异常信息并能够做针对的异常处理。 在你这样做时，请确保将原始异常设置为原因（注：参考下方代码 NumberFormatException e 中的原始异常 e ）。Exception 类提供了特殊的构造函数方法，它接受一个 Throwable 作为参数。否则，你将会丢失堆栈跟踪和原始异常的消息，这将会使分析导致异常的异常事件变得困难。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public void wrapException(String input) throws MyBusinessException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // do something</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (NumberFormatException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new MyBusinessException(&quot;A message that describes the error.&quot;, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="不要使用异常控制程序的流程">不要使用异常控制程序的流程<a href="#不要使用异常控制程序的流程" class="hash-link" aria-label="不要使用异常控制程序的流程的直接链接" title="不要使用异常控制程序的流程的直接链接">​</a></h4>
<p>不应该使用异常控制应用的执行流程，例如，本应该使用if语句进行条件判断的情况下，你却使用异常处理，这是非常不好的习惯，会严重影响应用的性能。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="不要在finally块中使用return">不要在finally块中使用return。<a href="#不要在finally块中使用return" class="hash-link" aria-label="不要在finally块中使用return。的直接链接" title="不要在finally块中使用return。的直接链接">​</a></h4>
<p>try块中的return语句执行成功后，并不马上返回，而是继续执行finally块中的语句，如果此处存在return语句，则在此直接返回，无情丢弃掉try块中的返回点。</p>
<p>如下是一个反例：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private int x = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public int checkReturn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // x等于1，此处不返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ++x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回的结果是2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ++x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="深入理解异常">深入理解异常<a href="#深入理解异常" class="hash-link" aria-label="深入理解异常的直接链接" title="深入理解异常的直接链接">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="jvm处理异常的机制">JVM处理异常的机制？<a href="#jvm处理异常的机制" class="hash-link" aria-label="JVM处理异常的机制？的直接链接" title="JVM处理异常的机制？的直接链接">​</a></h4>
<p>提到JVM处理异常的机制，就需要提及Exception Table，以下称为异常表。我们暂且不急于介绍异常表，先看一个简单的 Java 处理异常的小例子。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void simpleTryCatch() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       testNPE();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>上面的代码是一个很简单的例子，用来捕获处理一个潜在的空指针异常。</p>
<p>当然如果只是看简简单单的代码，我们很难看出什么高深之处，更没有了今天文章要谈论的内容。</p>
<p>所以这里我们需要借助一把神兵利器，它就是javap,一个用来拆解class文件的工具，和javac一样由JDK提供。</p>
<p>然后我们使用javap来分析这段代码（需要先使用javac编译）</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">//javap -c Main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> public static void simpleTryCatch();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: invokestatic  #3                  // Method testNPE:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       3: goto          11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       6: astore_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       7: aload_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       8: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      11: return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Exception table:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       from    to  target type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           0     3     6   Class java/lang/Exception</span><br></span></code></pre></div></div>
<p>看到上面的代码，应该会有会心一笑，因为终于看到了Exception table，也就是我们要研究的异常表。</p>
<p>异常表中包含了一个或多个异常处理者(Exception Handler)的信息，这些信息包含如下</p>
<ul>
<li><strong>from</strong> 可能发生异常的起始点</li>
<li><strong>to</strong> 可能发生异常的结束点</li>
<li><strong>target</strong> 上述from和to之前发生异常后的异常处理者的位置</li>
<li><strong>type</strong> 异常处理者处理的异常的类信息</li>
</ul>
<p><strong>那么异常表用在什么时候呢</strong></p>
<p>答案是异常发生的时候，当一个异常发生时</p>
<ul>
<li>1.JVM会在当前出现异常的方法中，查找异常表，是否有合适的处理者来处理</li>
<li>2.如果当前方法异常表不为空，并且异常符合处理者的from和to节点，并且type也匹配，则JVM调用位于target的调用者来处理。</li>
<li>3.如果上一条未找到合理的处理者，则继续查找异常表中的剩余条目</li>
<li>4.如果当前方法的异常表无法处理，则向上查找（弹栈处理）刚刚调用该方法的调用处，并重复上面的操作。</li>
<li>5.如果所有的栈帧被弹出，仍然没有处理，则抛给当前的Thread，Thread则会终止。</li>
<li>6.如果当前Thread为最后一个非守护线程，且未处理异常，则会导致JVM终止运行。</li>
</ul>
<p>以上就是JVM处理异常的一些机制。</p>
<p><strong>try catch -finally</strong></p>
<p>除了简单的try-catch外，我们还常常和finally做结合使用。比如这样的代码</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void simpleTryCatchFinally() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       testNPE();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       System.out.println(&quot;Finally&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>同样我们使用javap分析一下代码</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void simpleTryCatchFinally();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: invokestatic  #3                  // Method testNPE:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       6: ldc           #7                  // String Finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      11: goto          41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      14: astore_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      15: aload_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      22: ldc           #7                  // String Finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      27: goto          41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      30: astore_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      34: ldc           #7                  // String Finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      39: aload_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      40: athrow</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      41: return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Exception table:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       from    to  target type</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           0     3    14   Class java/lang/Exception</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           0     3    30   any</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          14    19    30   any</span><br></span></code></pre></div></div>
<p>和之前有所不同，这次异常表中，有三条数据，而我们仅仅捕获了一个Exception, 异常表的后两个item的type为any; 上面的三条异常表item的意思为:</p>
<ul>
<li>如果0到3之间，发生了Exception类型的异常，调用14位置的异常处理者。</li>
<li>如果0到3之间，无论发生什么异常，都调用30位置的处理者</li>
<li>如果14到19之间（即catch部分），不论发生什么异常，都调用30位置的处理者。</li>
</ul>
<p>再次分析上面的Java代码，finally里面的部分已经被提取到了try部分和catch部分。我们再次调一下代码来看一下</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static void simpleTryCatchFinally();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //try 部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至goto到41位置，执行返回操作。  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: invokestatic  #3                  // Method testNPE:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       3: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       6: ldc           #7                  // String Finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       8: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      11: goto          41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //catch部分提取finally代码，如果没有异常发生，则执行输出finally操作，直至执行got到41位置，执行返回操作。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      14: astore_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      15: aload_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      16: invokevirtual #5                  // Method java/lang/Exception.printStackTrace:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      19: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      22: ldc           #7                  // String Finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      24: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      27: goto          41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      //finally部分的代码如果被调用，有可能是try部分，也有可能是catch部分发生异常。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      30: astore_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      31: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      34: ldc           #7                  // String Finally</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      36: invokevirtual #8                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      39: aload_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      40: athrow     //如果异常没有被catch捕获，而是到了这里，执行完finally的语句后，仍然要把这个异常抛出去，传递给调用处。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      41: return</span><br></span></code></pre></div></div>
<p><strong>Catch先后顺序的问题</strong></p>
<p>我们在代码中的catch的顺序决定了异常处理者在异常表的位置，所以，越是具体的异常要先处理，否则就会出现下面的问题</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">private static void misuseCatchException() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       testNPE();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } catch (Throwable t) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       t.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } catch (Exception e) { //error occurs during compilings with tips Exception Java.lang.Exception has already benn caught.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>这段代码会导致编译失败，因为先捕获Throwable后捕获Exception，会导致后面的catch永远无法被执行。</p>
<p><strong>Return 和finally的问题</strong></p>
<p>这算是我们扩展的一个相对比较极端的问题，就是类似这样的代码，既有return，又有finally，那么finally导致会不会执行</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static String tryCatchReturn() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       testNPE();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return  &quot;OK&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } catch (Exception e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return &quot;ERROR&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   } finally {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       System.out.println(&quot;tryCatchReturn&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>答案是finally会执行，那么还是使用上面的方法，我们来看一下为什么finally会执行。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public static java.lang.String tryCatchReturn();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Code:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0: invokestatic  #3                  // Method testNPE:()V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       3: ldc           #6                  // String OK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       5: astore_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       6: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       9: ldc           #8                  // String tryCatchReturn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      11: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      14: aload_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      15: areturn       返回OK字符串，areturn意思为return a reference from a method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      16: astore_0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      17: ldc           #10                 // String ERROR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      19: astore_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      20: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      23: ldc           #8                  // String tryCatchReturn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      25: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      28: aload_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      29: areturn  //返回ERROR字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      30: astore_2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      31: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      34: ldc           #8                  // String tryCatchReturn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      36: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      39: aload_2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      40: athrow  如果catch有未处理的异常，抛出去。</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="异常是否耗时为什么会耗时">异常是否耗时？为什么会耗时？<a href="#异常是否耗时为什么会耗时" class="hash-link" aria-label="异常是否耗时？为什么会耗时？的直接链接" title="异常是否耗时？为什么会耗时？的直接链接">​</a></h4>
<p>说用异常慢，首先来看看异常慢在哪里？有多慢？下面的测试用例简单的测试了建立对象、建立异常对象、抛出并接住异常对象三者的耗时对比：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class ExceptionTest {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int testTimes;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ExceptionTest(int testTimes) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.testTimes = testTimes;  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void newObject() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long l = System.nanoTime();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; testTimes; i++) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Object();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;建立对象：&quot; + (System.nanoTime() - l));  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void newException() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long l = System.nanoTime();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; testTimes; i++) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new Exception();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;建立异常对象：&quot; + (System.nanoTime() - l));  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void catchException() {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        long l = System.nanoTime();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; testTimes; i++) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new Exception();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception e) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;建立、抛出并接住异常对象：&quot; + (System.nanoTime() - l));  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExceptionTest test = new ExceptionTest(10000);  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        test.newObject();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        test.newException();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        test.catchException();  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}  </span><br></span></code></pre></div></div>
<p>运行结果：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">建立对象：575817  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">建立异常对象：9589080  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">建立、抛出并接住异常对象：47394475  </span><br></span></code></pre></div></div>
<p>建立一个异常对象，是建立一个普通Object耗时的约20倍（实际上差距会比这个数字更大一些，因为循环也占用了时间，追求精确的读者可以再测一下空循环的耗时然后在对比前减掉这部分），而抛出、接住一个异常对象，所花费时间大约是建立异常对象的4倍。</p>
<p>那占用时间的“大头”：抛出、接住异常，系统到底做了什么事情？请参考这篇文章：</p>
<ul>
<li><a href="https://www.iteye.com/blog/icyfenix-857722" target="_blank" rel="noopener noreferrer">https://www.iteye.com/blog/icyfenix-857722</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_Donx" id="反射机制详解">反射机制详解<a href="#反射机制详解" class="hash-link" aria-label="反射机制详解的直接链接" title="反射机制详解的直接链接">​</a></h2>
<blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java反射机制在框架设计中极为广泛，需要深入理解。本文综合多篇文章后，总结了Java 反射的相关知识，希望可以提升你对Java中反射的认知效率。@pdai</p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="反射基础">反射基础<a href="#反射基础" class="hash-link" aria-label="反射基础的直接链接" title="反射基础的直接链接">​</a></h3>
<p>RTTI（Run-Time Type Identification）运行时类型识别。在《Thinking in Java》一书第十四章中有提到，其作用是在运行时识别一个对象的类型和类的信息。主要有两种方式：一种是“传统的”RTTI，它假定我们在编译时已经知道了所有的类型；另一种是“反射”机制，它允许我们在运行时发现和使用类的信息。</p>
<p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
<p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p>
<blockquote>
<p>这里我们首先需要理解 Class类，以及类的加载机制； 然后基于此我们如何通过反射获取Class类以及类中的成员变量、方法、构造方法等。</p>
</blockquote>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="class类">Class类<a href="#class类" class="hash-link" aria-label="Class类的直接链接" title="Class类的直接链接">​</a></h4>
<p>Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。Class类的实例表示java应用运行时的类(class ans enum)或接口(interface and annotation)（每个java类运行时都在JVM里表现为一个class对象，可通过类名.class、类型.getClass()、Class.forName(&quot;类名&quot;)等方法获取class对象）。数组同样也被映射为class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本类型boolean，byte，char，short，int，long，float，double和关键字void同样表现为 class 对象。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public final class Class&lt;T&gt; implements java.io.Serializable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              GenericDeclaration,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              Type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              AnnotatedElement {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int ANNOTATION= 0x00002000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int ENUM      = 0x00004000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final int SYNTHETIC = 0x00001000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static native void registerNatives();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        registerNatives();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Private constructor. Only the Java Virtual Machine creates Class objects.   //私有构造器，只有JVM才能调用创建Class对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * This constructor is not used and prevents the default constructor being</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * generated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Class(ClassLoader loader) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Initialize final field for classLoader.  The initialization value of non-null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // prevents future JIT optimizations from assuming this final field is null.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        classLoader = loader;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>到这我们也就可以得出以下几点信息：</p>
<ul>
<li>Class类也是类的一种，与class关键字是不一样的。</li>
<li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)</li>
<li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li>
<li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li>
<li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="类加载">类加载<a href="#类加载" class="hash-link" aria-label="类加载的直接链接" title="类加载的直接链接">​</a></h4>
<p>类加载机制和类字节码技术可以参考如下两篇文章：</p>
<ul>
<li>JVM基础 - 类字节码详解<!-- -->
<ul>
<li>源代码通过编译器编译为字节码，再通过类加载子系统进行加载到JVM中运行</li>
</ul>
</li>
<li>JVM基础 - Java 类加载机制<!-- -->
<ul>
<li>这篇文章将带你深入理解Java 类加载机制</li>
</ul>
</li>
</ul>
<p>其中，这里我们需要回顾的是：</p>
<ol>
<li>类加载机制流程</li>
</ol>
<p><img decoding="async" loading="lazy" alt="img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAmIAAAC7CAMAAADxJgIaAAAAUVBMVEX///8yMjLy8vLl5eWPkJCipKNJSUn+/8FeXlybXUfA//fPzc+ztrP4/ftkouiBfn40c69mMmH/sHNSU5KS0P/V2+TPklPq29L80JL/7d7f7/8dT+h6AAAOUklEQVR4nO2di3qqOhCFuYmggoJKad//QXcm3NW6M4SEYNd857hN65Q1yc8kJAE9T1jgTSycFgNOEb7wfVVEtcHXsC+qDb6GfVFt8DXsi2qDr2FfVBt8Dfui2uBr2BfVBl/Dvqg2+Br0DYUF4TsLOEVd3yiJfd+P6J3fmVOl4O0nA0dVMyIK3kcUJxGzfV2gfPDNkjYYURqFhpJTpSTjt68ziO38+PTwQ5hbFpxifzeUHn75a9EZxBL/5MEct6Of9O+3h1js37vC/noQr+VlXKrlK2xdC/24f789xHx/KFW5eEnzptAgtu+KsDVt1ErbRmx/rbtxZk6IlX0Btq59DGJeeuv7yZTQkt0k8tj69jmIUcd42xdy+CU7yjJvek/YuhYOjbxpxFL/QklsQCxtO0oM+R2ybWcxwVc6jMUKgdq+QA5zzLiIZTu5emPe4mSXvVD0hJgwmcX2qX/dF63zxYM5Y1zEEt+eyUWI56nXYVJPINZdQwqqaCxGzLX9JmxNi2fPi9lbvekWId52sqMsJsdiIpX5J3SVDtj8K0qbqzfNIsQ7xOoiIZzGV5Q0NkM3ub5xEQt6G63eGDexCBE8WRiMJIpZsbTvKMXlZd3MupaYel3dfD/gmPQJWk/PnsmDPWWx49GDOW/zO0oHELMqATbTgBjMsAExmGEDYjDD9mGImV5x6BYa1M0dRWsp+TDELKw4JDzG3FG0lpL5Oy1cRMz4isP0bgcFc0eRC0o+ADELKw7jux0UzB1FLij5AMQsrDiM73ZQMHcUuaBke4glyauP2ZBi6NMmFa2mZP5OCwcQe/0xG1IMfdqkotWUbPqK8vXHbEgx9GmTioCYgnYgpnOMzSA2bLqwjNirzTyno0qIi0sx92mTilZEbMObeZ4kADHdTxlQ8lmz+0BM91MGlNhBrJxscKZtz/viwNlY3yCWTTTNRoy2x96EKLkJu6abL9v1D6Vt2O+PEc5SJK269A/hqFgbwl8eIwtUPvVs+1RUTUW1QfcJUoEqyVe7z8YRxJr9z7viwHmqSYNY6CejNRCNLEZVt09jqappzq4yFaX8auc4OmZsRZU86W7ds4S6e6kU7596eYxpXSkroWM3t2/tW8SkGMXKWRsxmSzkG6rQlHX7WYcYLbXu2kwxGzG6V/xAj7uQjDdwLYaYUBifB8pUG3Z8+3rlx019KZ6CvyA2ritlJQJyekpDlQ+IcTubNz80hljTEV2amxvL8cq8svoRYn3NaSAmqi+lVkz77LokYpKyU8ZQ5FHfdGlPRUpplUjzvpaiaV15nEGEX5yKEzUOFa7aiNnZaSGqrsy7+2dl8lBv0uFgPWJUc9F9NmK1oL26yMqMrwnd2ZveFkaM7EwdlWot1cVudNrtZeOq5vm3iDV15SmffulBjJI7ukVyyMsuuc5VMjI7iLVj6wu1Kmcs9mxxNBOxclJjZYuY6oiDs3/qfFKvpbLNYr2SWr1h/2tihKiKmBwDpjd5ypXxLY1yT/kJR78c4/xWWr86v1gWE8PaVKouGZdNiyImBcnj160kXhZTt0QVsbo4dIh5wxWu8nB/ScQoi52afLqP2rGYScSGPUZaiAmJPWJVI7+MCkZX+dRRijqbv9Oi8s+XmgZkVHWlqY4yYXSU4rJ2eKyjHGgX6pdE/+soRV15vI4yyZu5i1y8VrqIvd9pEQ3bGHUQoy6xGsZicjBWs+7TniLW1NncNUpSQx32IaUapCuQfHnEzidOLe3bRzzOzWIvfjitK4YS6SRdr9GBbrLXRez9FeVCiIluYIqYOFcrP2c8JnM8aRG1nffsZfCseRpZTtOuNDKjoceiiJ2HGSnlqYIJYktlsb6ulJXQlPihn3TtnjvpPGJyXJ/mzbyYfBVJ7VrL2SlF66deRxM9OjstmjqTiFfLdpT9dAVHUZqP51sXymLjulJW0j0yq0dM1pTziMl5RVFzo46SptRLxnNz2gWkSZ29eKaFemcwniKoukHLAhfmYTZHkaylYY6uRUsri2XzlrJo8OVfB8ROUotVxJzazLPAMjjzrkj2MbAM/p/NPGd/h808WscAYnaG+wtpB2I6xwBiCtqBmM4xgJiCdiCmcwwgpqAdiOkcYzUl73dabA2x2A89w8a+G9wVRS4o+QDE8EwLt5V8AGI7Pz6affrMMZbfea1s7ihyQcn2EHvaaZFZeIZWzJqtdUfRakqs7LTQt9eIvahH408CjJx7SmLkzFMSoxlPSdwcYjD3DIjBDNumEcO3h2zBPmvqFeagcRELhQX0ElpGrD/uyIDYFky2XWMPLUjFsx9Nfyt9kMVgDJvfUVpYkOitWZkAYpu0+Yg58JWnQGwLNh8x4wsSw/HalQkgtkmbv9Mis/n18/HLr58HYhszJmLGFyQGa1cmgNjWjYtYZ+F//4xnyBeIbcy2h1jC2roFW8fm77TobT3EYFuw+VeUvQEx2DsDYjDDtmnEAksTczANC/wtj8VsLjDAZtr4npHtIWZvgQE206b3jDCfzDN6Qs580/TtFhgomQ2PwETJqVIczH0yT28rDve7BQZ3q3k3/V04/WQw9Qu2AM5DRMHbiMIoHt8zsvErSvhu0heIwReIwXfbvkAMvkAMvtv2BWLwBWLw3bYvEIMvEIPvtn2BGHyBGHy37QvE4AvE4Ltt3yU283wdhd2ffvx9/Ol8v+7BHFtxExF8F/PV38yTHe+0mePrmD389lv+RPp+3dVOCWSED/TV7ygFPiKNff1837Ppb0eIGZMPX/d9tRH7vgcCruz4k339iMK36DMzSm3HYyjeZIK+O7LYn/bVRkwMswRbxJfg6FvwJAZegrg70ZV5Xz+hGJIBsb/sq4/YzwSxzKNhvuw0246y/ZUZ+fB133ehLPYtM5ZHaAWi05RIyZ/Ji00g9pd9lxiL0YD//kNEScTEm682i4mEJrIYEPvTvtqIZcdQjO3vIl39eN1YzKPxl/ipROwbWexv++pPWhBCRBoNvL7vzRWk991eUVIRWexv+y6xgCQHXHJSTHaUNuXD133fZdcogRh8n4pADL6bQgy+8H0qAjH4bmAzj+ZmD/h+tq/rT+aB7+Z90VHCF4jBd9u+QAy+ayJm7TuQ4mSXGQzdZhyLNZdF0ePHHHpWEbP6TW5J5plCzH4cCzTXiqItIrbz49ODiyELTrHUYQYx+3Hoa15TtEXEHPhW3f/JVwrdfhz6mtcUbRGx2L97tuyX7wb/n3yl0O3Hoa95TdEWEbP6ZZDyYGYQsx+HvuY1RQMxduhAjCcaiLFDB2I80UCMHToQ44kGYuzQgRhPtHHEQmEBvYSWo+yP+5sFnOLI7Mehr3lN0bM1v/7w2Y+mv5WHRBbTi0NfMzpKQ1ECsd/+jk3RQIwdOhDjiQZi7NCBGE80EGOHDsR4ooEYO3QgxhMNxNihAzGeaCDGDh2I8UQDMXboQIwnGoixQwdiPNFAjB06EOOJdhSxKh+X9teDty8ORc6M8kHCCojt01v7Qv/090+oB/KEWDAtemqa1URXl1GhFpXevZL4vH/PFB1MhTmCWCkb4lKJl+uhaZldcaAwVW2CWHBKfG8VxGSr9IiJf0pqxWouYsEuYSQIfhY7H/aFrO3i0Cj1uiqvxU9mIhaeJqLdQKwmnG6yKZo2oiyWHjyGDYiFO3l/l7cKYlXUp65cF7EhEL5mJdGpzK9U0fR/SSLri2gMOkEowdWyGW6aopdHbHiCCms4MCBWju/QU24b35fHvEfd/YPLPTGGEUfTIHodZfAcCF+zoui9wEmMSAixQvYg50NzVtAvJGLpxaxovSfzMLJYo+vaZTHK1kqnzzhKzxsiXCuLlf6t7Kman8UeA+FrVhSdSprkwNdLb/W1PrfaRSASsUqpr3wr2pkryiGLtaODS3rjjcUiQ/fXx+px7Iv4JpiiWMrZiB0XCkThYGVxSPP22kr8V19SmW9LGg9LxFK10dhyol/aaQnEystoLCaSNLFV5eXFUzYnEKujdJLF+r/hJmIk9dKMuK6Cr9GZUF2oOWpfcbxvFrH4vhRidEUpEauaVimjgtFV0sGO53hSw/Y7SjpRvqjPkVmsOMzsKCcNNkuz2nD/VETFgQb2e9kldudHIYZkIoTKZ11R/iZat6N8XdTJYv2lc8049/sryiFOby3E0qtkq7kunn1FOQmEr1lNtBAqLoHzZmBfCqKk2mb8v/NzOS4uFTh7K9oZxOj8uVZR26eIlJZX4m3KuKLsjtsOO721EBNtdWmD8rQmLYZA+JqVEfPkgF52loWfjxBrryin07NzRLuBWO03rSKbQg73cxG6iFB9bmwy9RrukvUQq2n0RoHI80Nv6jWMEtNZjMb1pHJf5PsiajvKEWIqZ/n0YPdd4mAWa61vijSnk6dLByr2uIAUeusgtvOb+X1xHSR7GDEEEKeM+qDyaQEpnBY9Nc2qiJ3EeJc6kFszRzTNYs31Cm/qtVEVTouemmbPAmIahmXwT10Gf10EYnpx6GsGYoaiBGK//R2booEYO3QgxhMNxNihAzGeaCDGDh2I8UQbR2zWJpglopyzUWTpzTxm4piheTOiZ7SRPCSymF4c+prRURqKEoj99ndsigZi7NCBGE80EGOHDsR4ooEYO3QgxhMNxNihAzGeaCDGDh2I8UQDMXboQIwnGoixQwdiPNFAjB06EOOJtohY7D/4GzSzXxZoOw59zWuKtogYvvJ0bhz6mj/oK09fF5u3Oz8+PnzGkAXH2I88U4jZj0Nf85qiLSJm9RvQ4w/5+vl4i18/H5v8+vnn4njbRZQYfNLBOMQ4WmijyGtfi3Espnntyp+lWcmWIhW+8P1/R7mqBPgCMYflwxeIwffP+6La4GvYF9UGX8O+qDb4GvZFtcHXsC+qDb6GfVFt8DXsi2qDr2FfVBt8zfn+A22T0StJqrteAAAAAElFTkSuQmCC" width="610" height="187" class="img__I0M"></p>
<ol>
<li>类的加载</li>
</ol>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-reflection-3-04f5a7025af67c5ee871f3004b299685.png" width="1079" height="542" class="img__I0M"></p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="反射的使用">反射的使用<a href="#反射的使用" class="hash-link" aria-label="反射的使用的直接链接" title="反射的使用的直接链接">​</a></h3>
<p>提示</p>
<p>基于此我们如何通过反射获取Class类对象以及类中的成员变量、方法、构造方法等</p>
<p>在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private)，下面将对这几个重要类进行分别说明。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="class类对象的获取">Class类对象的获取<a href="#class类对象的获取" class="hash-link" aria-label="Class类对象的获取的直接链接" title="Class类对象的获取的直接链接">​</a></h4>
<p>在类加载的时候，jvm会创建一个class对象</p>
<p>class对象是可以说是反射中最常用的，获取class对象的方式的主要有三种</p>
<ul>
<li>根据类名：类名.class</li>
<li>根据对象：对象.getClass()</li>
<li>根据全限定类名：Class.forName(全限定类名)</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    @Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void classTest() throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取Class对象的三种方式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;根据类名:  \t&quot; + User.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;根据对象:  \t&quot; + new User().getClass());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;根据全限定类名:\t&quot; + Class.forName(&quot;com.test.User&quot;));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 常用的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;获取全限定类名:\t&quot; + userClass.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;获取类名:\t&quot; + userClass.getSimpleName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        logger.info(&quot;实例化:\t&quot; + userClass.newInstance());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    package com.test;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public class User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String name = &quot;init&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public User() {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public User(String name, int age) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        private void setName(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public int getAge() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void setAge(int age) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>输出结果：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">根据类名:  	class com.test.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">根据对象:  	class com.test.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">根据全限定类名:	class com.test.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">获取全限定类名:	com.test.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">获取类名:	User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">实例化:	User [name=init, age=0]</span><br></span></code></pre></div></div>
<ul>
<li>再来看看 <strong>Class类的方法</strong></li>
</ul>
<table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>forName()</td><td>(1)获取Class对象的一个引用，但引用的类还没有加载(该类的第一个对象没有生成)就加载了这个类。</td></tr><tr><td>(2)为了产生Class引用，forName()立即就进行了初始化。</td><td></td></tr><tr><td>Object-getClass()</td><td>获取Class对象的一个引用，返回表示该对象的实际类型的Class引用。</td></tr><tr><td>getName()</td><td>取全限定的类名(包括包名)，即类的完整名字。</td></tr><tr><td>getSimpleName()</td><td>获取类名(不包括包名)</td></tr><tr><td>getCanonicalName()</td><td>获取全限定的类名(包括包名)</td></tr><tr><td>isInterface()</td><td>判断Class对象是否是表示一个接口</td></tr><tr><td>getInterfaces()</td><td>返回Class对象数组，表示Class对象所引用的类所实现的所有接口。</td></tr><tr><td>getSupercalss()</td><td>返回Class对象，表示Class对象所引用的类所继承的直接基类。应用该方法可在运行时发现一个对象完整的继承结构。</td></tr><tr><td>newInstance()</td><td>返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。</td></tr><tr><td>getFields()</td><td>获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。</td></tr><tr><td>getDeclaredFields</td><td>获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。</td></tr></tbody></table>
<p>简单测试下（这里例子源于<a href="https://blog.csdn.net/mcryeasy/article/details/52344729%EF%BC%89" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/mcryeasy/article/details/52344729）</a></p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">package com.cry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Field;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface I1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interface I2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Cell{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int mCellPublic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Animal extends  Cell{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int mAnimalPrivate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected int mAnimalProtected;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int mAnimalDefault;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int mAnimalPublic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int sAnimalPrivate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected static int sAnimalProtected;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int sAnimalDefault;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static int sAnimalPublic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Dog extends Animal implements I1, I2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int mDogPrivate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int mDogPublic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected int mDogProtected;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int mDogDefault;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static int sDogPrivate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected static int sDogProtected;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    static int sDogDefault;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static int sDogPublic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws IllegalAccessException, InstantiationException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class&lt;Dog&gt; dog = Dog.class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //类名打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getName()); //com.cry.Dog</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getSimpleName()); //Dog</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getCanonicalName());//com.cry.Dog</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //接口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.isInterface()); //false</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Class iI : dog.getInterfaces()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(iI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          interface com.cry.I1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          interface com.cry.I2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //父类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(dog.getSuperclass());//class com.cry.Animal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Dog d = dog.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Field f : dog.getFields()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(f.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mDogPublic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sDogPublic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mAnimalPublic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            sAnimalPublic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            mCellPublic  //父类的父类的公共字段也打印出来了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;---------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Field f : dog.getDeclaredFields()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(f.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /** 只有自己类声明的字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         mDogPrivate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         mDogPublic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         mDogProtected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         mDogDefault</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         sDogPrivate</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         sDogProtected</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         sDogDefault</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         sDogPublic</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>getName、getCanonicalName与getSimpleName的区别</strong>：</p>
<ul>
<li>getSimpleName：只获取类名</li>
<li>getName：类的全限定名，jvm中Class的表示，可以用于动态加载Class对象，例如Class.forName。</li>
<li>getCanonicalName：返回更容易理解的表示，主要用于输出（toString）或log打印，大多数情况下和getName一样，但是在内部类、数组等类型的表示形式就不同了。</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">package com.cry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Test {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private  class inner{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //普通类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Test.class.getSimpleName()); //Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Test.class.getName()); //com.cry.Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(Test.class.getCanonicalName()); //com.cry.Test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //内部类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(inner.class.getSimpleName()); //inner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(inner.class.getName()); //com.cry.Test$inner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(inner.class.getCanonicalName()); //com.cry.Test.inner</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //数组</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(args.getClass().getSimpleName()); //String[]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(args.getClass().getName()); //[Ljava.lang.String;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(args.getClass().getCanonicalName()); //java.lang.String[]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //我们不能用getCanonicalName去加载类对象，必须用getName</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //Class.forName(inner.class.getCanonicalName()); 报错</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class.forName(inner.class.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="constructor类及其用法">Constructor类及其用法<a href="#constructor类及其用法" class="hash-link" aria-label="Constructor类及其用法的直接链接" title="Constructor类及其用法的直接链接">​</a></h4>
<blockquote>
<p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。</p>
</blockquote>
<p>获取Constructor对象是通过Class类中的方法获取的，Class类与Constructor相关的主要方法如下：</p>
<table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td><code>static Class&lt;?&gt;</code></td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td><code>getConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td><code>Constructor&lt;?&gt;[]</code></td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td><code>getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code></td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td><code>Constructor&lt;?&gt;[]</code></td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table>
<p>下面看一个简单例子来了解Constructor对象的使用：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class ConstructionTest implements Serializable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws Exception {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class&lt;?&gt; clazz = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取Class对象的引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clazz = Class.forName(&quot;com.example.javabase.User&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //第一种方法，实例化默认构造方法，User必须无参构造函数,否则将抛异常</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        User user = (User) clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        user.setAge(20);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        user.setName(&quot;Jack&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(user);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;--------------------------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取带String参数的public构造函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor cs1 =clazz.getConstructor(String.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        User user1= (User) cs1.newInstance(&quot;hiway&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        user1.setAge(22);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;user1:&quot;+user1.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;--------------------------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //取得指定带int和String参数构造函数,该方法是私有构造private</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor cs2=clazz.getDeclaredConstructor(int.class,String.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //由于是private必须设置可访问</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cs2.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //创建user对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        User user2= (User) cs2.newInstance(25,&quot;hiway2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;user2:&quot;+user2.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;--------------------------------------------&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取所有构造包含private</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor&lt;?&gt; cons[] = clazz.getDeclaredConstructors();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 查看每个构造方法需要的参数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; cons.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //获取构造函数参数类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;构造函数[&quot;+i+&quot;]:&quot;+cons[i].toString() );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.print(&quot;参数类型[&quot;+i+&quot;]:(&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (int j = 0; j &lt; clazzs.length; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (j == clazzs.length - 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.print(clazzs[j].getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    System.out.print(clazzs[j].getName() + &quot;,&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;)&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class User {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public User() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public User(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 私有构造</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param age</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private User(int age, String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        super();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getAge() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setAge(int age) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.age = age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setName(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.name = name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String toString() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;User{&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;age=&quot; + age +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &#x27;}&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>输出结果</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">/* output </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">User{age=20, name=&#x27;Jack&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user1:User{age=22, name=&#x27;hiway&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">user2:User{age=25, name=&#x27;hiway2&#x27;}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">构造函数[0]:private com.example.javabase.User(int,java.lang.String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数类型[0]:(int,java.lang.String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">构造函数[1]:public com.example.javabase.User(java.lang.String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数类型[1]:(java.lang.String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">构造函数[2]:public com.example.javabase.User()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数类型[2]:()</span><br></span></code></pre></div></div>
<p>关于<strong>Constructor类本身一些常用方法</strong>如下(仅部分，其他可查API)</p>
<table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Class</td><td>getDeclaringClass()</td><td>返回 Class 对象，该对象表示声明由此 Constructor 对象表示的构造方法的类,其实就是返回真实类型（不包含参数）</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回一组 Type 对象，返回的就是 Constructor对象构造函数的形参类型。</td></tr><tr><td>String</td><td>getName()</td><td>以字符串形式返回此构造方法的名称。</td></tr><tr><td><code>Class&lt;?&gt;[]</code></td><td>getParameterTypes()</td><td>按照声明顺序返回一组 Class 对象，即返回Constructor 对象所表示构造方法的形参类型</td></tr><tr><td>T</td><td>newInstance(Object... initargs)</td><td>使用此 Constructor对象表示的构造函数来创建新实例</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Constructor 的字符串，其中包括类型参数。</td></tr></tbody></table>
<p>代码演示如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Constructor cs3 = clazz.getDeclaredConstructor(int.class,String.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;-----getDeclaringClass-----&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class uclazz=cs3.getDeclaringClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//Constructor对象表示的构造方法的类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;构造方法的类:&quot;+uclazz.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;-----getGenericParameterTypes-----&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对象表示此 Constructor 对象所表示的方法的形参类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Type[] tps=cs3.getGenericParameterTypes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (Type tp:tps) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;参数名称tp:&quot;+tp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;-----getParameterTypes-----&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//获取构造函数参数类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class&lt;?&gt; clazzs[] = cs3.getParameterTypes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for (Class claz:clazzs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    System.out.println(&quot;参数名称:&quot;+claz.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;-----getName-----&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//以字符串形式返回此构造方法的名称</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;getName:&quot;+cs3.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;-----getoGenericString-----&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//返回描述此 Constructor 的字符串，其中包括类型参数。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;getoGenericString():&quot;+cs3.toGenericString());</span><br></span></code></pre></div></div>
<p>输出结果</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">-----getDeclaringClass-----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">构造方法的类:com.example.javabase.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-----getGenericParameterTypes-----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数名称tp:int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数名称tp:class java.lang.String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-----getParameterTypes-----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数名称:int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">参数名称:java.lang.String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-----getName-----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getName:com.example.javabase.User</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-----getoGenericString-----</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">getoGenericString():private com.example.javabase.User(int,java.lang.String)</span><br></span></code></pre></div></div>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="field类及其用法">Field类及其用法<a href="#field类及其用法" class="hash-link" aria-label="Field类及其用法的直接链接" title="Field类及其用法的直接链接">​</a></h4>
<blockquote>
<p>Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</p>
</blockquote>
<p>同样的道理，我们可以通过Class类的提供的方法来获取代表字段信息的Field对象，Class类与Field对象相关方法如下：</p>
<table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Field</td><td>getDeclaredField(String name)</td><td>获取指定name名称的(包含private修饰的)字段，不包括继承的字段</td></tr><tr><td>Field[]</td><td>getDeclaredFields()</td><td>获取Class对象所表示的类或接口的所有(包含private修饰的)字段,不包括继承的字段</td></tr><tr><td>Field</td><td>getField(String name)</td><td>获取指定name名称、具有public修饰的字段，包含继承字段</td></tr><tr><td>Field[]</td><td>getFields()</td><td>获取修饰符为public的字段，包含继承字段</td></tr></tbody></table>
<p>下面的代码演示了上述方法的使用过程</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class ReflectField {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class&lt;?&gt; clazz = Class.forName(&quot;reflect.Student&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取指定字段名称的Field类,注意字段修饰符必须为public而且存在该字段,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 否则抛NoSuchFieldException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field field = clazz.getField(&quot;age&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;field:&quot;+field);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取所有修饰符为public的字段,包含父类字段,注意修饰符为public才会获取</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field fields[] = clazz.getFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Field f:fields) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;f:&quot;+f.getDeclaringClass());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;================getDeclaredFields====================&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取当前类所字段(包含private字段),注意不包含父类的字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field fields2[] = clazz.getDeclaredFields();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Field f:fields2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;f2:&quot;+f.getDeclaringClass());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取指定字段名称的Field类,可以是任意修饰符的自动,注意不包含父类的字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Field field2 = clazz.getDeclaredField(&quot;desc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;field2:&quot;+field2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      输出结果: </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     field:public int reflect.Person.age</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     f:public java.lang.String reflect.Student.desc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     f:public int reflect.Person.age</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     f:public java.lang.String reflect.Person.name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ================getDeclaredFields====================</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     f2:public java.lang.String reflect.Student.desc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     f2:private int reflect.Student.score</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     field2:public java.lang.String reflect.Student.desc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Person{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int age;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略set和get方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Student extends Person{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int score;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略set和get方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>上述方法需要注意的是，如果我们不期望获取其父类的字段，则需使用Class类的getDeclaredField/getDeclaredFields方法来获取字段即可，倘若需要连带获取到父类的字段，那么请使用Class类的getField/getFields，但是也只能获取到public修饰的的字段，无法获取父类的私有字段。下面将通过Field类本身的方法对指定类属性赋值，代码演示如下：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">//获取Class对象引用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Class&lt;?&gt; clazz = Class.forName(&quot;reflect.Student&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Student st= (Student) clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//获取父类public字段并赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Field ageField = clazz.getField(&quot;age&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ageField.set(st,18);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Field nameField = clazz.getField(&quot;name&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nameField.set(st,&quot;Lily&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//只获取当前类的字段,不获取父类的字段</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Field descField = clazz.getDeclaredField(&quot;desc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">descField.set(st,&quot;I am student&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Field scoreField = clazz.getDeclaredField(&quot;score&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//设置可访问，score是private的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scoreField.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scoreField.set(st,88);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(st.toString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//输出结果：Student{age=18, name=&#x27;Lily ,desc=&#x27;I am student&#x27;, score=88} </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//获取字段值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(scoreField.get(st));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 88</span><br></span></code></pre></div></div>
<p>其中的set(Object obj, Object value)方法是Field类本身的方法，用于设置字段的值，而get(Object obj)则是获取字段的值，当然关于Field类还有其他常用的方法如下：</p>
<table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>void</td><td>set(Object obj, Object value)</td><td>将指定对象变量上此 Field 对象表示的字段设置为指定的新值。</td></tr><tr><td>Object</td><td>get(Object obj)</td><td>返回指定对象上此 Field 表示的字段的值</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td>getType()</td><td>返回一个 Class 对象，它标识了此Field 对象所表示字段的声明类型。</td></tr><tr><td>boolean</td><td>isEnumConstant()</td><td>如果此字段表示枚举类型的元素则返回 true；否则返回 false</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回一个描述此 Field（包括其一般类型）的字符串</td></tr><tr><td>String</td><td>getName()</td><td>返回此 Field 对象表示的字段的名称</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td>getDeclaringClass()</td><td>返回表示类或接口的 Class 对象，该类或接口声明由此 Field 对象表示的字段</td></tr><tr><td>void</td><td>setAccessible(boolean flag)</td><td>将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性</td></tr></tbody></table>
<p>上述方法可能是较为常用的，事实上在设置值的方法上，Field类还提供了专门针对基本数据类型的方法，如<code>setInt()/getInt()</code>、<code>setBoolean()/getBoolean</code>、<code>setChar()/getChar()</code>等等方法，这里就不全部列出了，需要时查API文档即可。需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="method类及其用法">Method类及其用法<a href="#method类及其用法" class="hash-link" aria-label="Method类及其用法的直接链接" title="Method类及其用法的直接链接">​</a></h4>
<blockquote>
<p>Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。</p>
</blockquote>
<p>下面是Class类获取Method对象相关的方法：</p>
<table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method</td><td><code>getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr><tr><td>Method</td><td><code>getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></td><td>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。</td></tr><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr></tbody></table>
<p>同样通过案例演示上述方法：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">import java.lang.reflect.Method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ReflectMethod  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class clazz = Class.forName(&quot;reflect.Circle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //根据参数获取public的Method,包含继承自父类的方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method method = clazz.getMethod(&quot;draw&quot;,int.class,String.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;method:&quot;+method);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取所有public的方法:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method[] methods =clazz.getMethods();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Method m:methods){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;m::&quot;+m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;=========================================&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取当前类的方法包含private,该方法无法获取继承自父类的method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method method1 = clazz.getDeclaredMethod(&quot;drawCircle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;method1::&quot;+method1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //获取当前类的所有方法包含private,该方法无法获取继承自父类的method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method[] methods1=clazz.getDeclaredMethods();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Method m:methods1){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            System.out.println(&quot;m1::&quot;+m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Shape {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;draw&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void draw(int count , String name){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;draw &quot;+ name +&quot;,count=&quot;+count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class Circle extends Shape{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void drawCircle(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;drawCircle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int getAllCount(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>输出结果:</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">method:public void reflect.Shape.draw(int,java.lang.String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public int reflect.Circle.getAllCount()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public void reflect.Shape.draw()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public void reflect.Shape.draw(int,java.lang.String)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public boolean java.lang.Object.equals(java.lang.Object)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public java.lang.String java.lang.Object.toString()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public native int java.lang.Object.hashCode()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public final native java.lang.Class java.lang.Object.getClass()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public final native void java.lang.Object.notify()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m::public final native void java.lang.Object.notifyAll()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">=========================================</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">method1::private void reflect.Circle.drawCircle()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m1::public int reflect.Circle.getAllCount()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">m1::private void reflect.Circle.drawCircle()</span><br></span></code></pre></div></div>
<p>在通过getMethods方法获取Method对象时，会把父类的方法也获取到，如上的输出结果，把Object类的方法都打印出来了。而<code>getDeclaredMethod/getDeclaredMethods</code>方法都只能获取当前类的方法。我们在使用时根据情况选择即可。下面将演示通过Method对象调用指定类的方法：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">Class clazz = Class.forName(&quot;reflect.Circle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//创建对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Circle circle = (Circle) clazz.newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//获取指定参数的方法对象Method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method method = clazz.getMethod(&quot;draw&quot;,int.class,String.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//通过Method对象的invoke(Object obj,Object... args)方法调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">method.invoke(circle,15,&quot;圈圈&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对私有无参方法的操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method method1 = clazz.getDeclaredMethod(&quot;drawCircle&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//修改私有方法的访问标识</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">method1.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">method1.invoke(circle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//对有返回值得方法操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Method method2 =clazz.getDeclaredMethod(&quot;getAllCount&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Integer count = (Integer) method2.invoke(circle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">System.out.println(&quot;count:&quot;+count);</span><br></span></code></pre></div></div>
<p>输出结果</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">draw 圈圈,count=15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">drawCircle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">count:100</span><br></span></code></pre></div></div>
<p>在上述代码中调用方法，使用了Method类的<code>invoke(Object obj,Object... args)</code>第一个参数代表调用的对象，第二个参数传递的调用方法的参数。这样就完成了类方法的动态调用。</p>
<table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Object</td><td>invoke(Object obj, Object... args)</td><td>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</td></tr><tr><td><code>Class&lt;?&gt;</code></td><td>getReturnType()</td><td>返回一个 Class 对象，该对象描述了此 Method 对象所表示的方法的正式返回类型,即方法的返回类型</td></tr><tr><td>Type</td><td>getGenericReturnType()</td><td>返回表示由此 Method 对象所表示方法的正式返回类型的 Type 对象，也是方法的返回类型。</td></tr><tr><td><code>Class&lt;?&gt;[]</code></td><td>getParameterTypes()</td><td>按照声明顺序返回 Class 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型。即返回方法的参数类型组成的数组</td></tr><tr><td>Type[]</td><td>getGenericParameterTypes()</td><td>按照声明顺序返回 Type 对象的数组，这些对象描述了此 Method 对象所表示的方法的形参类型的，也是返回方法的参数类型</td></tr><tr><td>String</td><td>getName()</td><td>以 String 形式返回此 Method 对象表示的方法名称，即返回方法的名称</td></tr><tr><td>boolean</td><td>isVarArgs()</td><td>判断方法是否带可变参数，如果将此方法声明为带有可变数量的参数，则返回 true；否则，返回 false。</td></tr><tr><td>String</td><td>toGenericString()</td><td>返回描述此 Method 的字符串，包括类型参数。</td></tr></tbody></table>
<p><code>getReturnType方法/getGenericReturnType方法</code>都是获取Method对象表示的方法的返回类型，只不过前者返回的Class类型后者返回的Type(前面已分析过)，Type就是一个接口而已，在Java8中新增一个默认的方法实现，返回的就参数类型信息</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public interface Type {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //1.8新增</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    default String getTypeName() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return toString();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>而<code>getParameterTypes/getGenericParameterTypes</code>也是同样的道理，都是获取Method对象所表示的方法的参数类型，其他方法与前面的Field和Constructor是类似的。</p>
<h3 class="anchor anchorWithStickyNavbar_Donx" id="反射机制执行的流程">反射机制执行的流程<a href="#反射机制执行的流程" class="hash-link" aria-label="反射机制执行的流程的直接链接" title="反射机制执行的流程的直接链接">​</a></h3>
<blockquote>
<p>这部分主要参考自<a href="https://www.cnblogs.com/yougewe/p/10125073.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/yougewe/p/10125073.html</a></p>
</blockquote>
<p><strong>先看个例子</strong></p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">public class HelloReflect {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 1. 使用外部配置的实现，进行动态加载类</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            TempFunctionTest test = (TempFunctionTest)Class.forName(&quot;com.tester.HelloReflect&quot;).newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            test.sayHello(&quot;call directly&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 2. 根据配置的函数名，进行方法调用（不需要通用的接口抽象）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object t2 = new TempFunctionTest();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Method method = t2.getClass().getDeclaredMethod(&quot;sayHello&quot;, String.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            method.invoke(test, &quot;method invoke&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (ClassNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InstantiationException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IllegalAccessException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (NoSuchMethodException e ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InvocationTargetException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            e.printStackTrace();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void sayHello(String word) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        System.out.println(&quot;hello,&quot; + word);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>来看执行流程</strong></p>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/java-basic-reflection-1-e0c80f3734a15b46a8089b9e04793de6.png" width="2720" height="1678" class="img__I0M"></p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="反射获取类实例">反射获取类实例<a href="#反射获取类实例" class="hash-link" aria-label="反射获取类实例的直接链接" title="反射获取类实例的直接链接">​</a></h4>
<p>首先调用了 java.lang.Class 的静态方法，获取类信息。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    @CallerSensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Class&lt;?&gt; forName(String className)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先通过反射，获取调用进来的类信息，从而获取当前的 classLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用native方法进行获取class信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>forName()反射获取类信息，并没有将实现留给了java,而是交给了jvm去加载。</p>
<p>主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader.</p>
<p>最后，jvm又会回调 ClassLoader 进类加载。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return loadClass(name, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // sun.misc.Launcher</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        public Class&lt;?&gt; loadClass(String var1, boolean var2) throws ClassNotFoundException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            int var3 = var1.lastIndexOf(46);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(var3 != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                SecurityManager var4 = System.getSecurityManager();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(var4 != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    var4.checkPackageAccess(var1.substring(0, var3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if(this.ucp.knownToNotExist(var1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Class var5 = this.findLoadedClass(var1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if(var5 != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if(var2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        this.resolveClass(var5);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return var5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new ClassNotFoundException(var1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return super.loadClass(var1, var2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // java.lang.ClassLoader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws ClassNotFoundException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 先获取锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (getClassLoadingLock(name)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // First, check if the class has already been loaded</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果已经加载了的话，就不用再加载了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; c = findLoadedClass(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (c == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                long t0 = System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 双亲委托加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (parent != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        c = parent.loadClass(name, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        c = findBootstrapClassOrNull(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (ClassNotFoundException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // ClassNotFoundException thrown if class not found</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // from the non-null parent class loader</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 父类没有加载到时，再自己加载</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (c == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // If still not found, then invoke findClass in order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // to find the class.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    long t1 = System.nanoTime();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    c = findClass(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // this is the defining class loader; record the stats</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (resolve) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                resolveClass(c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Object getClassLoadingLock(String className) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object lock = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (parallelLockMap != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用 ConcurrentHashMap来保存锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Object newLock = new Object();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            lock = parallelLockMap.putIfAbsent(className, newLock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (lock == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                lock = newLock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected final Class&lt;?&gt; findLoadedClass(String name) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!checkName(name))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return findLoadedClass0(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>下面来看一下 newInstance() 的实现方式。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // 首先肯定是 Class.newInstance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @CallerSensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T newInstance()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InstantiationException, IllegalAccessException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (System.getSecurityManager() != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // NOTE: the following code may not be strictly correct under</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // the current Java memory model.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Constructor lookup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // newInstance() 其实相当于调用类的无参构造函数，所以，首先要找到其无参构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (cachedConstructor == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this == Class.class) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 不允许调用 Class 的 newInstance() 方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new IllegalAccessException(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 获取无参构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Class&lt;?&gt;[] empty = {};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                final Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // Disable accessibility checks on the constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // since we have to do the security check here anyway</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // (the stack depth is wrong for the Constructor&#x27;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // security check to work)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                java.security.AccessController.doPrivileged(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new java.security.PrivilegedAction&lt;Void&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        public Void run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                c.setAccessible(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                cachedConstructor = c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (NoSuchMethodException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw (InstantiationException)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new InstantiationException(getName()).initCause(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Security check (same as in java.lang.reflect.Constructor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int modifiers = tmpConstructor.getModifiers();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (newInstanceCallerCache != caller) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Reflection.ensureMemberAccess(caller, this, null, modifiers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newInstanceCallerCache = caller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Run constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 调用无参构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return tmpConstructor.newInstance((Object[])null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InvocationTargetException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Unsafe.getUnsafe().throwException(e.getTargetException());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Not reached</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>newInstance() 主要做了三件事：</p>
<ul>
<li>
<ol>
<li>权限检测，如果不通过直接抛出异常；</li>
</ol>
</li>
<li>
<ol>
<li>查找无参构造器，并将其缓存起来；</li>
</ol>
</li>
<li>
<ol>
<li>调用具体方法的无参构造方法，生成实例并返回；</li>
</ol>
</li>
</ul>
<p>下面是获取构造器的过程：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        int which) throws NoSuchMethodException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 获取所有构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Constructor&lt;T&gt; constructor : constructors) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (arrayContentsEq(parameterTypes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                constructor.getParameterTypes())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return getReflectionFactory().copyConstructor(constructor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>getConstructor0() 为获取匹配的构造方器；分三步：</p>
<ul>
<li>
<ol>
<li>先获取所有的constructors, 然后通过进行参数类型比较；</li>
</ol>
</li>
<li>
<ol>
<li>找到匹配后，通过 ReflectionFactory copy一份constructor返回；</li>
</ol>
</li>
<li>
<ol>
<li>否则抛出 NoSuchMethodException;</li>
</ol>
</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取当前类所有的构造方法，通过jvm或者缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Returns an array of &quot;root&quot; constructors. These Constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // objects must NOT be propagated to the outside world, but must</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // instead be copied via ReflectionFactory.copyConstructor.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkInitted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor&lt;T&gt;[] res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用 reflectionData(), 获取保存的信息，使用软引用保存，从而使内存不够可以回收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rd != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 存在缓存，则直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (res != null) return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // No cached value available; request value from VM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isInterface()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            @SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = temporaryRes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 使用native方法从jvm获取构造器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = getDeclaredConstructors0(publicOnly);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rd != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 最后，将从jvm中读取的内容，存入缓存</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (publicOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rd.publicConstructors = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rd.declaredConstructors = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Lazily create and cache ReflectionData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ReflectionData&lt;T&gt; reflectionData() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int classRedefinedCount = this.classRedefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReflectionData&lt;T&gt; rd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (useCaches &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            reflectionData != null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (rd = reflectionData.get()) != null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rd.redefinedCount == classRedefinedCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return rd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // else no SoftReference or cleared SoftReference or stale ReflectionData</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // -&gt; create and replace new instance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newReflectionData(reflectionData, classRedefinedCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 新创建缓存，保存反射信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                int classRedefinedCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!useCaches) return null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用cas保证更新的线程安全性，所以反射是保证线程安全的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (true) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // try to CAS it...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return rd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 先使用CAS更新，如果更新成功，则立即返回，否则测查当前已被其他线程更新的情况，如果和自己想要更新的状态一致，则也算是成功了</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            oldReflectionData = this.reflectionData;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            classRedefinedCount = this.classRedefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (oldReflectionData != null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (rd = oldReflectionData.get()) != null &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rd.redefinedCount == classRedefinedCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return rd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>如上，privateGetDeclaredConstructors(), 获取所有的构造器主要步骤；</p>
<ul>
<li>
<ol>
<li>先尝试从缓存中获取；</li>
</ol>
</li>
<li>
<ol>
<li>如果缓存没有，则从jvm中重新获取，并存入缓存，缓存使用软引用进行保存，保证内存可用；</li>
</ol>
</li>
</ul>
<p>另外，使用 relactionData() 进行缓存保存；ReflectionData 的数据结构如下。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // reflection data that might get invalidated when JVM TI RedefineClasses() is called</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static class ReflectionData&lt;T&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Field[] declaredFields;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Field[] publicFields;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Method[] declaredMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Method[] publicMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Constructor&lt;T&gt;[] declaredConstructors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Constructor&lt;T&gt;[] publicConstructors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Intermediate results for getFields and getMethods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Field[] declaredPublicFields;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Method[] declaredPublicMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        volatile Class&lt;?&gt;[] interfaces;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Value of classRedefinedCount when we created this ReflectionData instance</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final int redefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReflectionData(int redefinedCount) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.redefinedCount = redefinedCount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>其中，还有一个点，就是如何比较构造是否是要查找构造器，其实就是比较类型完成相等就完了，有一个不相等则返回false。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    private static boolean arrayContentsEq(Object[] a1, Object[] a2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (a1 == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return a2 == null || a2.length == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (a2 == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return a1.length == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (a1.length != a2.length) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; a1.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (a1[i] != a2[i]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sun.reflect.ReflectionFactory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /** Makes a copy of the passed constructor. The returned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        constructor is a &quot;child&quot; of the passed one; see the comments</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        in Constructor.java for details. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; Constructor&lt;T&gt; copyConstructor(Constructor&lt;T&gt; arg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return langReflectAccess().copyConstructor(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // java.lang.reflect.Constructor, copy 其实就是新new一个 Constructor 出来</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Constructor&lt;T&gt; copy() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This routine enables sharing of ConstructorAccessor objects</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // among Constructor objects which refer to the same underlying</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // method in the VM. (All of this contortion is only necessary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // because of the &quot;accessibility&quot; bit in AccessibleObject,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // which implicitly requires that new java.lang.reflect</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // objects be fabricated for each reflective call on Class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // objects.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (this.root != null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;Can not copy a non-root Constructor&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Constructor&lt;T&gt; res = new Constructor&lt;&gt;(clazz,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                               parameterTypes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                               exceptionTypes, modifiers, slot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                               signature,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                               annotations,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                               parameterAnnotations);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // root 指向当前 constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.root = this;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Might as well eagerly propagate this if already present</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res.constructorAccessor = constructorAccessor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>通过上面，获取到 Constructor 了。</p>
<p>接下来就只需调用其相应构造器的 newInstance()，即返回实例了。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // return tmpConstructor.newInstance((Object[])null); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // java.lang.reflect.Constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @CallerSensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public T newInstance(Object ... initargs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InstantiationException, IllegalAccessException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               IllegalArgumentException, InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!override) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                checkAccess(caller, clazz, null, modifiers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((clazz.getModifiers() &amp; Modifier.ENUM) != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalArgumentException(&quot;Cannot reflectively create enum objects&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConstructorAccessor ca = constructorAccessor;   // read volatile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ca == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ca = acquireConstructorAccessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        @SuppressWarnings(&quot;unchecked&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        T inst = (T) ca.newInstance(initargs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return inst;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sun.reflect.DelegatingConstructorAccessorImpl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object newInstance(Object[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      throws InstantiationException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             IllegalArgumentException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return delegate.newInstance(args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sun.reflect.NativeConstructorAccessorImpl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object newInstance(Object[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws InstantiationException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               IllegalArgumentException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // We can&#x27;t inflate a constructor belonging to a vm-anonymous class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // because that kind of class can&#x27;t be referred to by name, hence can&#x27;t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // be found from the generated bytecode.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(c.getDeclaringClass())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConstructorAccessorImpl acc = (ConstructorAccessorImpl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new MethodAccessorGenerator().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    generateConstructor(c.getDeclaringClass(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        c.getParameterTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        c.getExceptionTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        c.getModifiers());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent.setDelegate(acc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 调用native方法，进行调用 constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newInstance0(c, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>返回构造器的实例后，可以根据外部进行进行类型转换，从而使用接口或方法进行调用实例功能了。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="反射获取方法">反射获取方法<a href="#反射获取方法" class="hash-link" aria-label="反射获取方法的直接链接" title="反射获取方法的直接链接">​</a></h4>
<ul>
<li><strong>第一步，先获取 Method</strong>;</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // java.lang.Class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @CallerSensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws NoSuchMethodException, SecurityException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (method == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>忽略第一个检查权限，剩下就只有两个动作了。</p>
<ul>
<li>
<ol>
<li>获取所有方法列表；</li>
</ol>
</li>
<li>
<ol>
<li>根据方法名称和方法列表，选出符合要求的方法；</li>
</ol>
</li>
<li>
<ol>
<li>如果没有找到相应方法，抛出异常，否则返回对应方法；</li>
</ol>
</li>
</ul>
<p>所以，先看一下怎样获取类声明的所有方法？</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // Returns an array of &quot;root&quot; methods. These Method objects must NOT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // be propagated to the outside world, but must instead be copied</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // via ReflectionFactory.copyMethod.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Method[] privateGetDeclaredMethods(boolean publicOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkInitted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method[] res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ReflectionData&lt;T&gt; rd = reflectionData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rd != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (res != null) return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // No cached value available; request value from VM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (rd != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (publicOnly) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rd.declaredPublicMethods = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rd.declaredMethods = res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>很相似，和获取所有构造器的方法很相似，都是先从缓存中获取方法，如果没有，则从jvm中获取。</p>
<p>不同的是，方法列表需要进行过滤 Reflection.filterMethods;当然后面看来，这个方法我们一般不会派上用场。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // sun.misc.Reflection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static Method[] filterMethods(Class&lt;?&gt; containingClass, Method[] methods) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (methodFilterMap == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Bootstrapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return methods;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (Method[])filter(methods, methodFilterMap.get(containingClass));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 可以过滤指定的方法，一般为空，如果要指定过滤，可以调用 registerMethodsToFilter(), 或者...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static Member[] filter(Member[] members, String[] filteredNames) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((filteredNames == null) || (members.length == 0)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return members;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int numNewMembers = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Member member : members) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean shouldSkip = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (String filteredName : filteredNames) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (member.getName() == filteredName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    shouldSkip = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!shouldSkip) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ++numNewMembers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Member[] newMembers =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (Member[])Array.newInstance(members[0].getClass(), numNewMembers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int destIdx = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (Member member : members) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean shouldSkip = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (String filteredName : filteredNames) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (member.getName() == filteredName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    shouldSkip = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!shouldSkip) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                newMembers[destIdx++] = member;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return newMembers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<ul>
<li><strong>第二步，根据方法名和参数类型过滤指定方法返回</strong>：</li>
</ul>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    private static Method searchMethods(Method[] methods,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        String name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        Class&lt;?&gt;[] parameterTypes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method res = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用常量池，避免重复创建String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        String internedName = name.intern();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; methods.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Method m = methods[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (m.getName() == internedName</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; (res == null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    || res.getReturnType().isAssignableFrom(m.getReturnType())))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                res = m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (res == null ? res : getReflectionFactory().copyMethod(res));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>大概意思看得明白，就是匹配到方法名，然后参数类型匹配，才可以。</p>
<ul>
<li>但是可以看到，匹配到一个方法，并没有退出for循环，而是继续进行匹配。</li>
<li>这里是匹配最精确的子类进行返回（最优匹配）</li>
<li>最后，还是通过 ReflectionFactory, copy 方法后返回。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="调用-methodinvoke-方法">调用 method.invoke() 方法<a href="#调用-methodinvoke-方法" class="hash-link" aria-label="调用 method.invoke() 方法的直接链接" title="调用 method.invoke() 方法的直接链接">​</a></h4>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    @CallerSensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(Object obj, Object... args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws IllegalAccessException, IllegalArgumentException,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!override) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                checkAccess(caller, clazz, obj, modifiers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MethodAccessor ma = methodAccessor;             // read volatile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ma == null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ma = acquireMethodAccessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ma.invoke(obj, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>invoke时，是通过 MethodAccessor 进行调用的，而 MethodAccessor 是个接口，在第一次时调用 acquireMethodAccessor() 进行新创建。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    // probably make the implementation more scalable.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MethodAccessor acquireMethodAccessor() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // First check to see if one has been created yet, and take it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if so</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        MethodAccessor tmp = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (root != null) tmp = root.getMethodAccessor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (tmp != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 存在缓存时，存入 methodAccessor，否则调用 ReflectionFactory 创建新的 MethodAccessor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            methodAccessor = tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Otherwise fabricate one and propagate it up to the root</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            tmp = reflectionFactory.newMethodAccessor(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setMethodAccessor(tmp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // sun.reflect.ReflectionFactory</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MethodAccessor newMethodAccessor(Method method) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        checkInitted();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new MethodAccessorGenerator().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                generateMethod(method.getDeclaringClass(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               method.getName(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               method.getParameterTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               method.getReturnType(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               method.getExceptionTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               method.getModifiers());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            NativeMethodAccessorImpl acc =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new NativeMethodAccessorImpl(method);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            DelegatingMethodAccessorImpl res =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new DelegatingMethodAccessorImpl(acc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            acc.setParent(res);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>两个Accessor详情：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">//     NativeMethodAccessorImpl / DelegatingMethodAccessorImpl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class NativeMethodAccessorImpl extends MethodAccessorImpl {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Method method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private DelegatingMethodAccessorImpl parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private int numInvocations;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    NativeMethodAccessorImpl(Method method) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.method = method;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(Object obj, Object[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws IllegalArgumentException, InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // We can&#x27;t inflate methods belonging to vm-anonymous classes because</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // found from the generated bytecode.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new MethodAccessorGenerator().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    generateMethod(method.getDeclaringClass(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getName(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getParameterTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getReturnType(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getExceptionTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getModifiers());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent.setDelegate(acc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return invoke0(method, obj, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void setParent(DelegatingMethodAccessorImpl parent) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.parent = parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static native Object invoke0(Method m, Object obj, Object[] args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">class DelegatingMethodAccessorImpl extends MethodAccessorImpl {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MethodAccessorImpl delegate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DelegatingMethodAccessorImpl(MethodAccessorImpl delegate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setDelegate(delegate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(Object obj, Object[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws IllegalArgumentException, InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return delegate.invoke(obj, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void setDelegate(MethodAccessorImpl delegate) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.delegate = delegate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>进行 ma.invoke(obj, args); 调用时，调用 DelegatingMethodAccessorImpl.invoke();</p>
<p>最后被委托到 NativeMethodAccessorImpl.invoke(), 即：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(Object obj, Object[] args)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throws IllegalArgumentException, InvocationTargetException</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // We can&#x27;t inflate methods belonging to vm-anonymous classes because</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // that kind of class can&#x27;t be referred to by name, hence can&#x27;t be</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // found from the generated bytecode.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (++numInvocations &gt; ReflectionFactory.inflationThreshold()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                &amp;&amp; !ReflectUtil.isVMAnonymousClass(method.getDeclaringClass())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            MethodAccessorImpl acc = (MethodAccessorImpl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                new MethodAccessorGenerator().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    generateMethod(method.getDeclaringClass(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getName(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getParameterTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getReturnType(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getExceptionTypes(),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                   method.getModifiers());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            parent.setDelegate(acc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // invoke0 是个 native 方法，由jvm进行调用业务方法。从而完成反射调用功能。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return invoke0(method, obj, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>其中， generateMethod() 是生成具体类的方法：</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    /** This routine is not thread-safe */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public MethodAccessor generateMethod(Class&lt;?&gt; declaringClass,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         String   name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         Class&lt;?&gt;[] parameterTypes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         Class&lt;?&gt;   returnType,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         Class&lt;?&gt;[] checkedExceptions,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         int modifiers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (MethodAccessor) generate(declaringClass,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         parameterTypes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         returnType,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         checkedExceptions,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         modifiers,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         false,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         null);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>generate() 戳详情。</p>
<div class="language-java codeBlockContainer_lFgc theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_x5WI"><pre tabindex="0" class="prism-code language-java codeBlock_wUdx thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_H_lr"><span class="token-line" style="color:#393A34"><span class="token plain">    /** This routine is not thread-safe */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private MagicAccessorImpl generate(final Class&lt;?&gt; declaringClass,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       String name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       Class&lt;?&gt;[] parameterTypes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       Class&lt;?&gt;   returnType,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       Class&lt;?&gt;[] checkedExceptions,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       int modifiers,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       boolean isConstructor,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       boolean forSerialization,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       Class&lt;?&gt; serializationTargetClass)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ByteVector vec = ByteVectorFactory.create();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm = new ClassFileAssembler(vec);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.declaringClass = declaringClass;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.parameterTypes = parameterTypes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.returnType = returnType;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.modifiers = modifiers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.isConstructor = isConstructor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.forSerialization = forSerialization;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitMagicAndVersion();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Constant pool entries:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ( * = Boxing information: optional)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // (+  = Shared entries provided by AccessorGenerator)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // (^  = Only present if generating SerializationConstructorAccessor)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] [This class&#x27;s name]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] &quot;sun/reflect/{MethodAccessorImpl,ConstructorAccessorImpl,SerializationConstructorAccessorImpl}&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] [Target class&#x27;s name]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ^   [UTF-8] [Serialization: Class&#x27;s name in which to invoke constructor]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ^   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] target method or constructor name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] target method or constructor signature</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info] for target method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] &quot;invoke&quot; or &quot;newInstance&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] invoke or newInstance descriptor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] descriptor for type of non-primitive parameter 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_Class_info] for type of non-primitive parameter 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [UTF-8] descriptor for type of non-primitive parameter n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //     [CONSTANT_Class_info] for type of non-primitive parameter n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;java/lang/Exception&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;java/lang/ClassCastException&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;java/lang/NullPointerException&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;java/lang/IllegalArgumentException&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;java/lang/InvocationTargetException&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;&lt;init&gt;&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;()V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Methodref_info] for NullPointerException&#x27;s constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;(Ljava/lang/String;)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/String;)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Methodref_info] for IllegalArgumentException&#x27;s constructor taking a String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;(Ljava/lang/Throwable;)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_NameAndType_info] for &quot;&lt;init&gt;(Ljava/lang/Throwable;)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Methodref_info] for InvocationTargetException&#x27;s constructor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Methodref_info] for &quot;super()&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;java/lang/Object&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;toString&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;()Ljava/lang/String;&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_NameAndType_info] for &quot;toString()Ljava/lang/String;&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [CONSTANT_Methodref_info] for Object&#x27;s toString method</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;Code&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // +   [UTF-8] &quot;Exceptions&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Boolean&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(Z)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;booleanValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()Z&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Byte&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(B)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;byteValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()B&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Character&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(C)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;charValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()C&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Double&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(D)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;doubleValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()D&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Float&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(F)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;floatValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()F&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Integer&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(I)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;intValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()I&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Long&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(J)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;longValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()J&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;java/lang/Short&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Class_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;(S)V&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;shortValue&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [UTF-8] &quot;()S&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_NameAndType_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        //  *  [CONSTANT_Methodref_info] for above</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        short numCPEntries = NUM_BASE_CPOOL_ENTRIES + NUM_COMMON_CPOOL_ENTRIES;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        boolean usesPrimitives = usesPrimitiveTypes();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (usesPrimitives) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numCPEntries += NUM_BOXING_CPOOL_ENTRIES;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (forSerialization) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            numCPEntries += NUM_SERIALIZATION_CPOOL_ENTRIES;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Add in variable-length number of entries to be able to describe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // non-primitive parameter types and checked exceptions.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        numCPEntries += (short) (2 * numNonPrimitiveParameterTypes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(add(numCPEntries, S1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String generatedName = generateName(isConstructor, forSerialization);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolUTF8(generatedName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolClass(asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        thisClass = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isConstructor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (forSerialization) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                asm.emitConstantPoolUTF8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (&quot;sun/reflect/SerializationConstructorAccessorImpl&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                asm.emitConstantPoolUTF8(&quot;sun/reflect/ConstructorAccessorImpl&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolUTF8(&quot;sun/reflect/MethodAccessorImpl&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolClass(asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        superClass = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolUTF8(getClassName(declaringClass, false));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolClass(asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetClass = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        short serializationTargetClassIdx = (short) 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (forSerialization) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolUTF8(getClassName(serializationTargetClass, false));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolClass(asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            serializationTargetClassIdx = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolUTF8(name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolUTF8(buildInternalSignature());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitConstantPoolNameAndType(sub(asm.cpi(), S1), asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isInterface()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolInterfaceMethodref(targetClass, asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (forSerialization) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                asm.emitConstantPoolMethodref(serializationTargetClassIdx, asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                asm.emitConstantPoolMethodref(targetClass, asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetMethodRef = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isConstructor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolUTF8(&quot;newInstance&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolUTF8(&quot;invoke&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        invokeIdx = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (isConstructor) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolUTF8(&quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            asm.emitConstantPoolUTF8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (&quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        invokeDescriptorIdx = asm.cpi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Output class information for non-primitive parameter types</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nonPrimitiveParametersBaseIdx = add(asm.cpi(), S2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (int i = 0; i &lt; parameterTypes.length; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Class&lt;?&gt; c = parameterTypes[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!isPrimitive(c)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                asm.emitConstantPoolUTF8(getClassName(c, false));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                asm.emitConstantPoolClass(asm.cpi());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Entries common to FieldAccessor, MethodAccessor and ConstructorAccessor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emitCommonConstantPoolEntries();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Boxing entries</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (usesPrimitives) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emitBoxingContantPoolEntries();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (asm.cpi() != numCPEntries) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new InternalError(&quot;Adjust this code (cpi = &quot; + asm.cpi() +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    &quot;, numCPEntries = &quot; + numCPEntries + &quot;)&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Access flags</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(ACC_PUBLIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // This class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(thisClass);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Superclass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(superClass);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Interfaces count and interfaces</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(S0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Fields count and fields</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(S0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Methods count and methods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(NUM_METHODS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emitConstructor();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emitInvoke();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Additional attributes (none)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        asm.emitShort(S0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Load class</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        vec.trim();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        final byte[] bytes = vec.getData();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // Note: the class loader is the only thing that really matters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // here -- it&#x27;s important to get the generated code into the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // same namespace as the target class. Since the generated code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // is privileged anyway, the protection domain probably doesn&#x27;t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // matter.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return AccessController.doPrivileged(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            new PrivilegedAction&lt;MagicAccessorImpl&gt;() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                public MagicAccessorImpl run() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return (MagicAccessorImpl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ClassDefiner.defineClass</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                (generatedName,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 bytes,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 bytes.length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 declaringClass.getClassLoader()).newInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } catch (InstantiationException | IllegalAccessException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            throw new InternalError(e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span></code></pre></div></div>
<p>咱们主要看这一句：<code>ClassDefiner.defineClass(xx, declaringClass.getClassLoader()).newInstance()</code>;</p>
<p>在<code>ClassDefiner.defineClass</code>方法实现中，每被调用一次都会生成一个DelegatingClassLoader类加载器对象 ，这里每次都生成新的类加载器，是为了性能考虑，在某些情况下可以卸载这些生成的类，因为类的卸载是只有在类加载器可以被回收的情况下才会被回收的，如果用了原来的类加载器，那可能导致这些新创建的类一直无法被卸载。</p>
<p>而反射生成的类，有时候可能用了就可以卸载了，所以使用其独立的类加载器，从而使得更容易控制反射类的生命周期。</p>
<h4 class="anchor anchorWithStickyNavbar_Donx" id="反射调用流程小结">反射调用流程小结<a href="#反射调用流程小结" class="hash-link" aria-label="反射调用流程小结的直接链接" title="反射调用流程小结的直接链接">​</a></h4>
<p>最后，用几句话总结反射的实现原理：</p>
<ol>
<li>反射类及反射方法的获取，都是通过从列表中搜寻查找匹配的方法，所以查找性能会随类的大小方法多少而变化；</li>
<li>每个类都会有一个与之对应的Class实例，从而每个类都可以获取method反射方法，并作用到其他实例身上；</li>
<li>反射也是考虑了线程安全的，放心使用；</li>
<li>反射使用软引用relectionData缓存class信息，避免每次重新从jvm获取带来的开销；</li>
<li>反射调用多次生成新代理Accessor, 而通过字节码生存的则考虑了卸载功能，所以会使用独立的类加载器；</li>
<li>当找到需要的方法，都会copy一份出来，而不是使用原来的实例，从而保证数据隔离；</li>
<li>调度反射方法，最终是由jvm执行invoke0()执行；</li>
</ol>
<p><a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/java/advanced/java-advanced-spi.html</a></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/book/java/Java 基础.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_w8N_" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_I1LX"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/book/java/"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Java</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_OqFH thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#java-基础---面向对象" class="table-of-contents__link toc-highlight">Java 基础 - 面向对象</a><ul><li><a href="#三大特性" class="table-of-contents__link toc-highlight">三大特性</a></li></ul></li><li><a href="#java-基础---知识点" class="table-of-contents__link toc-highlight">Java 基础 - 知识点</a><ul><li><a href="#数据类型" class="table-of-contents__link toc-highlight">数据类型</a></li><li><a href="#string" class="table-of-contents__link toc-highlight">String</a></li><li><a href="#运算" class="table-of-contents__link toc-highlight">运算</a></li><li><a href="#继承-1" class="table-of-contents__link toc-highlight">继承</a></li><li><a href="#object-通用方法" class="table-of-contents__link toc-highlight">Object 通用方法</a></li><li><a href="#关键字" class="table-of-contents__link toc-highlight">关键字</a></li><li><a href="#反射" class="table-of-contents__link toc-highlight">反射</a></li><li><a href="#异常" class="table-of-contents__link toc-highlight">异常</a></li><li><a href="#泛型" class="table-of-contents__link toc-highlight">泛型</a></li><li><a href="#注解" class="table-of-contents__link toc-highlight">注解</a></li><li><a href="#特性" class="table-of-contents__link toc-highlight">特性</a></li></ul></li><li><a href="#java-基础---图谱--qa" class="table-of-contents__link toc-highlight">Java 基础 - 图谱 &amp; Q/A</a><ul><li><a href="#知识体系" class="table-of-contents__link toc-highlight">知识体系</a></li><li><a href="#qa" class="table-of-contents__link toc-highlight">Q&amp;A</a></li></ul></li><li><a href="#java-基础---泛型机制详解" class="table-of-contents__link toc-highlight">Java 基础 - 泛型机制详解</a><ul><li><a href="#为什么会引入泛型" class="table-of-contents__link toc-highlight">为什么会引入泛型</a></li><li><a href="#泛型的基本使用" class="table-of-contents__link toc-highlight">泛型的基本使用</a></li><li><a href="#深入理解泛型" class="table-of-contents__link toc-highlight">深入理解泛型</a></li></ul></li><li><a href="#注解机制详解" class="table-of-contents__link toc-highlight">注解机制详解</a><ul><li><a href="#注解基础" class="table-of-contents__link toc-highlight">注解基础</a></li><li><a href="#深入理解注解" class="table-of-contents__link toc-highlight">深入理解注解</a></li><li><a href="#注解的应用场景" class="table-of-contents__link toc-highlight">注解的应用场景</a></li></ul></li><li><a href="#异常机制详解" class="table-of-contents__link toc-highlight">异常机制详解</a><ul><li><a href="#异常的层次结构" class="table-of-contents__link toc-highlight">异常的层次结构</a></li><li><a href="#异常基础" class="table-of-contents__link toc-highlight">异常基础</a></li><li><a href="#异常实践" class="table-of-contents__link toc-highlight">异常实践</a></li><li><a href="#深入理解异常" class="table-of-contents__link toc-highlight">深入理解异常</a></li></ul></li><li><a href="#反射机制详解" class="table-of-contents__link toc-highlight">反射机制详解</a><ul><li><a href="#反射基础" class="table-of-contents__link toc-highlight">反射基础</a></li><li><a href="#反射的使用" class="table-of-contents__link toc-highlight">反射的使用</a></li><li><a href="#反射机制执行的流程" class="table-of-contents__link toc-highlight">反射机制执行的流程</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025</div></div></div></footer></div>
</body>
</html>